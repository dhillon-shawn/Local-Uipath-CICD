name: Bootstrap an existing Repo (w Studio Project)

on:
  workflow_dispatch:
    inputs:
      repo_name:
        description: "Target repo name"
        required: true

      reviewers:
        description: "GitHub usernames for prod reviewers"
        required: false

      folder_name:
        description: "New Projects - FullyQualified Folder Name - Ex: Grandma/Mom/Daughter (creates Daughter SubFolder) or Orphan (Creates Standalone Folder)"
        default: ""
        required: false
permissions: write-all

env:
  scope: "OR.Folders OR.BackgroundTasks OR.TestSets OR.TestSetExecutions OR.TestSetSchedules OR.Settings.Read OR.Robots.Read OR.Machines OR.Execution OR.Assets OR.Users.Read OR.Jobs OR.Monitoring OR.Robots"
  FOLDER_VARS: |
                "dev": {
                  "MID": "",
                  "DEV_RID": "6144536",
                  "DEV_UID": "12616150",
                  "BOT_UID": "",
                  "BOT_RID": "6144535",
                },
                "test": {
                  "MID": "5296531",
                  "DEV_RID": "6951189",
                  "DEV_UID": "12506499",
                  "BOT_UID": "12507013",
                  "BOT_RID": "6144537",
                },
                "prod": {
                  "MID": "",
                  "DEV_RID": "6144536",
                  "DEV_UID": "12616150",
                  "BOT_UID": "",
                  "BOT_RID": "6144535",
                }
              

jobs:
  BOOTSTRAP:
    runs-on: ubuntu-latest
    outputs:
      pid: ${{ steps.repo.outputs.PID }}
      folder: ${{ steps.folder.outputs.FOLDER_TO_SET}}
    steps:
      - name: Checkout controller repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Mint App installation token
        id: inst
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.WORKFLOW_APP_ID }}
          private_key: ${{ secrets.WORKFLOW_PEM }}

      - name: Export App token
        run: echo "GH_TOKEN=${{ steps.inst.outputs.token }}" >> $GITHUB_ENV

      - name: Get Default Branch
        id: get_default
        env:
          REPO: ${{ inputs.repo_name}}
        run: |
          default_branch=$(
            curl -sSf -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository_owner }}/$REPO" | jq -r '.default_branch'
          )
          echo "Default Branch: $default_branch"
          echo "DEFAULT_BRANCH=$default_branch" >> $GITHUB_OUTPUT

      - name: check
        run: |
          echo "${{ steps.get_default.outputs.DEFAULT_BRANCH }} "

      - name: Repo Level
        id: repo
        env:
          repo: ${{ inputs.repo_name }}
          default_branch: ${{ steps.get_default.outputs.DEFAULT_BRANCH }}
        run: |
          set -euo pipefail

          git clone --depth=1 "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository_owner }}/${repo}"
          cd "$(basename "$repo")"

          git config --global --add safe.directory "$(pwd)"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          REPO_SLUG="${{ github.repository_owner }}/${repo}"

          # -------------------------
          # Update default branch
          # -------------------------
          git switch "${default_branch}"
          git pull --ff-only origin "${default_branch}"

          mkdir -p .github/workflows
          cp "$GITHUB_WORKSPACE/templates/Issues/issues.yml"             .github/workflows/
          cp -r "$GITHUB_WORKSPACE/templates/Issues/ISSUE_TEMPLATE"     .github/

          cp "$GITHUB_WORKSPACE/templates/CICD.yml"                     .github/workflows/

          cp "$GITHUB_WORKSPACE/templates/.gitignore"                   .
          cp "$GITHUB_WORKSPACE/templates/nuget.config"                 .

          git add .github .gitignore nuget.config
          if ! git diff --cached --quiet -- .github .gitignore nuget.config; then
            git commit -m "update .github, .gitignore, nuget.config on ${default_branch} [skip ci]"
            if ! git push origin "${default_branch}"; then
              echo "::notice:: push to ${default_branch} blocked."
              exit 1
            fi
          else
            git reset -q
            echo "No .github/.gitignore/nuget.config changes on ${default_branch}."
          fi

          if [[ -f "./project.json" ]]; then
            PID="$(jq -er '.name' ./project.json)"
            echo "PID=$PID" >> "$GITHUB_ENV"
            echo "PID=$PID" >> "$GITHUB_OUTPUT"
            echo "Project ID: $PID"
          fi

      - name: Protect default branch with a ruleset
        env:
          REPO: ${{ inputs.repo_name }}
          default_branch: ${{ steps.get_default.outputs.DEFAULT_BRANCH }}
          WORKFLOW_APP_ID: ${{ secrets.WORKFLOW_APP_ID }}
        run: |
          set -euo pipefail

          payload="$(
            jq -nc \
              --arg name "Protect ${default_branch}" \
              --arg ref  "refs/heads/${default_branch}" \
              --arg appId "${WORKFLOW_APP_ID}" '
              {
                name: $name,
                target: "branch",
                enforcement: "active",
                conditions: { ref_name: { include: [ $ref ], exclude: [] } },
                bypass_actors: [
                  { actor_id: ($appId|tonumber), actor_type: "Integration", bypass_mode: "always" }
                ],
                rules: [
                  {
                    type: "pull_request",
                    parameters: {
                      required_approving_review_count: 1,
                      dismiss_stale_reviews_on_push: true,
                      require_code_owner_review: false,
                      require_last_push_approval: true,
                      required_review_thread_resolution: true
                    }
                  }
                ]
              }'
          )"

          response=$(curl -sS  -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/${REPO}/rulesets" \
            -d "${payload}"
          )
          echo "Response: $response"

      - name: turn on auto merge and delete on merge
        env:
          REPO: ${{ inputs.repo_name }}
        run: |
          curl -L -sSf \
            -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/$REPO" \
            -d '{"allow_auto_merge": true, "delete_branch_on_merge": true}'

      - name: Parse reviewers â†’ numeric IDs (for prod env gate)
        id: parse_reviewers
        env:
          REVIEWERS: ${{ inputs.reviewers }}
        run: |
          set -euo pipefail
          users=$(echo "$REVIEWERS" | tr ', ' '\n' | sed '/^$/d' | sort -u)
          ids=()
          for u in $users; do
            id=$(gh api "users/$u" --jq .id || echo "")
            [ -n "$id" ] && ids+=("$id")
          done
          echo "gh_ids=$(IFS=,; echo "${ids[*]}")" >> $GITHUB_OUTPUT

      - name: Auth
        if: inputs.folder_name == ''
        uses: dhillon-shawn/Local-CICD-UTILS/auth@v0
        with:
          target_env: "DEV"
          role_arn: ${{ secrets.RPA_UIPATH_CICD_ROLE_ARN }}
          aws_region: "us-west-2"
          secret_id: ${{ secrets.RPA_UIPATH_CICD_SECRET_ARN }}
          scopes: ${{ env.scope }}

      - name: Scavenge Folder
        if: inputs.folder_name == ''
        run: |
          echo "Iterating through folder checking releases for a Process ID (${{ env.PID }}) match"

          FOLDERS=$(curl --location \
            --header "Authorization: Bearer $TOKEN" \
            "${{ env.OR_URL }}/odata/Folders?\$select=Id,FullyQualifiedName"
          )

          echo "Folders Response: $FOLDERS"

          FOUND_FOLDER=""
          while IFS=$'\t' read -r fid fname || [ -n "$fid" ]; do

            fid=${fid%$'\r'}
            fname=${fname%$'\r'}

            [ -n "$fid" ] || continue
            echo "Checking folder: $fname ($fid)"

            response=$(curl --location \
              --header "Authorization: Bearer $TOKEN" \
              --header "X-UIPATH-OrganizationUnitId: $fid" \
              "${{ env.OR_URL }}/odata/Releases?%24select=Id%2CProcessKey%2CName%2CProcessType&%24filter=ProcessKey%20eq%20%27${{ env.PID }}%27"
            )
            echo "Release Response: $response"

            id_found=$(printf '%s' "$response" | jq -r '.value[0].Id // empty')
            if [ -n "$id_found" ]; then
              echo "Found Release ID: $id_found in folder $fname ($fid)"
              FOUND_FOLDER="$fname"
              break
            fi
          done < <(
            printf '%s' "$FOLDERS" \
            | jq -r '.value[] | [.Id, (.FullyQualifiedName // "")] | @tsv' \
            | tr -d '\r'
          )

          if [ -n "$FOUND_FOLDER" ]; then
            echo "FOUND_FOLDER=$FOUND_FOLDER" >> "$GITHUB_ENV"
          else
            echo "::error::No folder with a matching Release (Process ID == ${{ env.PID }}) was found."
            exit 1
          fi

      - name: Resolve folder
        id: folder
        env:
          folder_name: ${{ inputs.folder_name }}
        run: |
          set -euo pipefail

          FOLDER_NAME="${folder_name:-}"
          if [ -z "${FOLDER_NAME}" ]; then
            FOLDER_NAME="${FOUND_FOLDER:-}"
          fi

          echo "Will set FOLDER_NAME='${FOLDER_NAME}'"
          echo "FOLDER_TO_SET=${FOLDER_NAME}" >> "$GITHUB_ENV"
          echo "FOLDER_TO_SET=${FOLDER_NAME}" >> "$GITHUB_OUTPUT"

      - name: Create/update environments + vars (uses App token)
        env:
          REPO: ${{ inputs.repo_name }}
          REVIEWER_IDS: ${{ steps.parse_reviewers.outputs.gh_ids }}
        run: |
          set -euo pipefail

          for env in dev test prod hotfix; do
              echo "Creating $env" 
              reviewers_block="$(
                jq -nc --arg ids "$REVIEWER_IDS" --arg env "$env" '
                  if $env == "prod" and ($ids|length>0) then
                    ($ids
                    | split(",")
                    | map(select(length>0) | tonumber)
                    | map({type:"User", id:.}))
                  else
                    []
                  end
                '
              )"

              payload="$(jq -nc --argjson reviewers "$reviewers_block" '
                {
                  wait_timer: 0,
                  reviewers: $reviewers
                }
              ')"

              echo "Payload: $payload"

              curl  -X PUT \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository_owner }}/$REPO/environments/$env" \
              -d "$payload"


              echo "==================="            
              echo "$env created"
              echo "==================="
             
              VARIABLES_JSON='{
                "dev": {
                  "FOLDER_NAME" : "${{ env.FOLDER_TO_SET}}"
                },
                "test": {
                  "FOLDER_NAME" : "${{ env.FOLDER_TO_SET}}"
                },
                "prod": {
                  "FOLDER_NAME" : "${{ env.FOLDER_TO_SET}}"
                },
                "hotfix": {
                  "FOLDER_NAME" : "${{ env.FOLDER_TO_SET}}"
                }
              }'

              echo "Creating or updating environment vars for $env"

              while IFS=$'\t' read -r name value; do
                payload_create=$(jq -nc --arg name "$name" --arg value "$value" '{name:$name, value:$value}')
                payload_update=$(jq -nc --arg value "$value" '{value:$value}')
                
                code=$(curl -sS -o /dev/null -w "%{http_code}" -X POST \
                  -H "Authorization: Bearer $GH_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  -H "Content-Type: application/json" \
                  "https://api.github.com/repos/${{ github.repository_owner }}/$REPO/environments/$env/variables" \
                  -d "$payload_create")

                if [[ "$code" == "201" ]]; then
                  echo "Created: $name"
                elif [[ "$code" == "409" || "$code" == "422" ]]; then
                  curl -sS -o /dev/null -X PATCH \
                    -H "Authorization: Bearer $GH_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    -H "Content-Type: application/json" \
                    "https://api.github.com/repos/${{ github.repository_owner }}/$REPO/environments/$env/variables/$name" \
                    -d "$payload_update"
                  echo "Updated: $name"
                else
                  echo "POST $name failed with HTTP $code" >&2
                  exit 1
                fi
              done < <(
                echo "$VARIABLES_JSON" \
                | jq -r --arg env "$env" '.[$env] // {} | to_entries[] | "\(.key)\t\(.value)"'
              )
          done

      - name: Add Labels
        env:
          REPO: ${{ inputs.repo_name }}
        run: |
          set -e

          payload='{"name":"release","color":"1f6feb","description":"New release"}'
          response=$(curl -sS  -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/${REPO}/labels" \
            -d "${payload}")
          echo "response: $response"

          payload='{"name":"hotfix","color":"d73a4a","description":"Urgent production fix"}'
          response=$(curl -sS  -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/${REPO}/labels" \
            -d "${payload}")
          echo "response: $response"
          
          payload='{"name":"library","color":"7e3ad7","description":"library project"}'
          response=$(curl -sS  -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/${REPO}/labels" \
            -d "${payload}")
          echo "response: $response"

          payload='{"name":"process","color":"d76e3a","description":"process project"}'
          response=$(curl -sS  -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/${REPO}/labels" \
            -d "${payload}")
          echo "response: $response"

          echo "Labels added."
          
      - name: set token permissions
        env:
          REPO: ${{ inputs.repo_name }}
        run: |
          payload='{"default_workflow_permissions":"write","can_approve_pull_request_reviews":true}'

          response=$(curl -sS -X PUT \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/${REPO}/actions/permissions/workflow" \
            -d "${payload}"
          )
          echo "Response: $response"
          
      - name: PRINT RESULTS - UPDATE
        run: |
          echo " "
          echo "====================================================================================="
          echo "Link to existing repo: https://github.com/${{ github.repository_owner }}/${{inputs.repo_name}}"
          echo "====================================================================================="
          echo " "

  ensure-folders:
    runs-on: ubuntu-latest
    needs: BOOTSTRAP
    strategy:
      matrix:
        env: [dev, test, prod]

    steps:
      - name: set vars
        shell: bash
        run: |
          {
            echo "dev_rid=${{ fromJSON(env.FOLDER_VARS).DEV_RID }}"
            echo "bot_rid=${{ fromJSON(env.FOLDER_VARS).BOT_RID }}"
            echo "mid=${{ fromJSON(env.FOLDER_VARS).MID }}"
            echo "bot_uid=${{ fromJSON(env.FOLDER_VARS).BOT_UID }}"
            echo "dev_uid=${{ fromJSON(env.FOLDER_VARS).DEV_UID }}"
          } >> "$GITHUB_ENV"

      - name: Create folders
        id: ensure
        shell: bash
        run: |
          # --------------------------------------------------------------------------------
          # Example: GreatGrandma/Grandma/Mom/Daughter
          # PARENT_FQN == everything before our target subfolder == GreatGrandma/Grandma
          # PARENT_NAME == The direct parent of our target subfolder == Mom
          # CHILD_NAME == our target subfolder == Daughter

          # orphan                              -> orphan
          # GreatGrandma/Grandma/Mom/Daughter   -> Daughter
          # GreatGrandma/Grandma                -> Grandma
          # --------------------------------------------------------------------------------
          
          FULLY_QUALIFIED="${{ needs.BOOTSTRAP.outputs.folder }}"

          trimmed="${FULLY_QUALIFIED%/}"
          folder="${trimmed##*/}"

          echo "FULLY_QUALIFIED='${FULLY_QUALIFIED}' -> folder='${folder}'"

          if [[ "${trimmed}" == *"/"* ]]; then
            PARENT_FQN="${trimmed%/*}"   
            PARENT_NAME="${PARENT_FQN##*/}" 
          else
            PARENT_FQN=""
            PARENT_NAME=""
          fi

          echo "parent_fqn='${PARENT_FQN}' parent_name='${PARENT_NAME}'"

          echo "folder=${folder}" >> "$GITHUB_OUTPUT"
          
          
          FOUND_ID=""
          FOUND_NAME=""
          if [ -n "$FULLY_QUALIFIED" ]; then
              echo "Searching by name: $FULLY_QUALIFIED"
              response=$(curl  -H "Authorization: Bearer ${{ env.TOKEN }}" \
                "${{ env.OR_URL }}/odata/Folders?\$filter=FullyQualifiedName%20eq%20'$FULLY_QUALIFIED'&\$select=Id,FullyQualifiedName")
              echo "Response: $response"
              
              FOUND_ID=$(echo "$response" | jq -r '.value[0].Id // empty')
              FOUND_NAME=$(echo "$response" | jq -r '.value[0].FullyQualifiedName // empty')
              if [ -n "$FOUND_ID" ] && [ -n "$FOUND_NAME" ]; then
                echo "Folder Found: $FOUND_NAME ($FOUND_ID)"
                echo "FID=$FOUND_ID" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              echo "Did not find folder by FullyQualifiedName"
          fi


          # ===============================================================================================
          # Create
          # must check if fully qualified name includes sub folders
          # we are only creating the last subfolder and using the second to last folder as the parent id
          # ex: FullyQualifiedName: Grandma/Mom/Daughter -> we create daughter folder using Mom id
          # *Note:this process isn't recursive so if Grandma or Mom folder don't exist we fail*
          # ===============================================================================================

          if [ -z "$FULLY_QUALIFIED" ]; then
            echo "No FOLDER NAME to Create"
            exit 1;
          fi

          if [ -z "$FOUND_ID" ]; then
            if [ -n "$PARENT_NAME" ]; then
              echo "Getting parent folder id"
              parent_response=$(curl  --location  \
                --header "Authorization: Bearer ${{ env.TOKEN }}" \
                --header "Content-Type: application/json" \
                "${{ env.OR_URL }}/odata/Folders?\$select=Id&\$filter=DisplayName%20eq%20'$PARENT_NAME'"
              )
              echo "Response: $parent_response"
              PARENT_ID=$(echo "$parent_response" | jq -r '.Id // .value[0].Id // empty')

              echo "Creating Sub Folder"
              response=$(curl  --location --request POST \
                --header "Authorization: Bearer ${{ env.TOKEN }}" \
                --header "Content-Type: application/json" \
                --data "{
                    \"DisplayName\": \"$folder\",
                    \"Description\": \"Created via API\",
                    \"FullyQualifiedName\": \"$FULLY_QUALIFIED\",
                    \"ProvisionType\": \"Automatic\",
                    \"PermissionModel\": \"FineGrained\",
                    \"FeedType\": \"Processes\",
                    \"ParentId\": $PARENT_ID
                }" \
                "${{ env.OR_URL }}/odata/Folders"
              )
              echo "Response: $response"
            else
              echo "Creating Folder (Not a SubFolder)"
              response=$(curl --fail --location --request POST \
                --header "Authorization: Bearer ${{ env.TOKEN }}" \
                --header "Content-Type: application/json" \
                --data "{
                    \"DisplayName\": \"$FULLY_QUALIFIED\",
                    \"Description\": \"Created via API\",
                    \"FullyQualifiedName\": \"$FULLY_QUALIFIED\",
                    \"ProvisionType\": \"Automatic\",
                    \"PermissionModel\": \"FineGrained\",
                    \"FeedType\": \"Processes\"
                }" \
                "${{ env.OR_URL }}/odata/Folders"
              )
              echo "Response: $response"
            fi

            FOUND_ID=$(echo "$response" | jq -r '.Id // .value[0].Id // empty')
            FOUND_NAME=$(echo "$response" | jq -r '.FullyQualifiedName // .value[0].FullyQualifiedName // empty')

            echo "FID=$FOUND_ID" >> "$GITHUB_OUTPUT"

          # ===============================================================================================
          # Now That Folder is Created We Allocate
          # We assign a bot user with robot role
          # We assign user/directory group with a developer role
          # We assign a machine with testing license
          # ===============================================================================================


            res=$(curl  --location --request POST \
                --header "Authorization: Bearer ${{ env.TOKEN }}" \
                --header "Content-Type: application/json" \
                --header "X-UIPATH-OrganizationUnitId: $FOUND_ID" \
                --data "{
                        \"assignments\": {
                          \"UserIds\": [ ${{ env.dev_uid}} ],
                          \"RolesPerFolder\": [
                            { \"FolderId\": $FOUND_ID,
                              \"RoleIds\": [ ${{ env.dev_rid }} ] }
                          ]
                        }
                      }" \
                "${{ env.OR_URL }}/odata/Folders/UiPath.Server.Configuration.OData.AssignUsers"
            )
            echo "Response: $res"
            echo "Assigned User/User Role to Created Folder"

            if [ "${{ env.target_env }}" != "prod" ]; then
              re=$(curl  --location --request POST \
                  --header "Authorization: Bearer ${{ env.TOKEN }}" \
                  --header "Content-Type: application/json" \
                  --header "X-UIPATH-OrganizationUnitId: $FOUND_ID" \
                  --data "{
                          \"assignments\": {
                            \"UserIds\": [ ${{ env.bot_uid}} ],
                            \"RolesPerFolder\": [
                              { \"FolderId\": $FOUND_ID,
                                \"RoleIds\": [ ${{ env.bot_rid }} ] }
                            ]
                          }
                        }" \
                  "${{ env.OR_URL }}/odata/Folders/UiPath.Server.Configuration.OData.AssignUsers"
              )
              echo "Response: $re"
              echo "Assigned Bot/Bot Role to Created Folder"

              r=$(curl  --location --request POST \
                  --header "Authorization: Bearer ${{ env.TOKEN }}" \
                  --header "Content-Type: application/json" \
                  --header "X-UIPATH-OrganizationUnitId: $FOUND_ID" \
                  --data "{
                            \"assignments\": {
                              \"FolderIds\": [ $FOUND_ID ],
                              \"MachineIds\": [ ${{ env.mid }} ]
                            }
                          }" \
                  "${{ env.OR_URL }}/odata/Folders/UiPath.Server.Configuration.OData.AssignMachines"
              )
              echo "Response: $r"
              echo "Assigned Machine to Created Folder"
              exit 0
            fi
          fi
          echo "Failed to find or create a folder"
  copy:
    runs-on: ubuntu-latest
    needs: [BOOTSTRAP]
    env:
      TOKEN: ${{ secrets.USER_PAT }}
      TARGET_OWNER: ${{ github.repository_owner }}
      TARGET_REPO: ${{ inputs.repo_name }}
    strategy:
      matrix:
        name:
          [
            EMAIL_USERNAME,
            EMAIL_PASSWORD,
            RPA_UIPATH_CICD_ROLE_ARN,
            RPA_UIPATH_CICD_SECRET_ARN,
          ]

    steps:
      - name: Get destination repo public key
        run: |
          set -e
          KEY_RESP="$(curl -sS \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${TARGET_OWNER}/${TARGET_REPO}/actions/secrets/public-key")"
          echo "$KEY_RESP" | jq .
          echo "KEY_ID=$(echo "$KEY_RESP" | jq -r .key_id)" >> "$GITHUB_ENV"
          echo "PUBKEY=$(echo "$KEY_RESP" | jq -r .key)"    >> "$GITHUB_ENV"

      - name: Install PyNaCl
        run: python3 -m pip install --quiet pynacl

      - name: Encrypt & upload ${{ matrix.name }}
        env:
          SECRET_NAME: ${{ matrix.name }}
          SECRET_VALUE: ${{ secrets[matrix.name] }}
        run: |
          set -euo pipefail
          [ -n "${SECRET_VALUE:-}" ] || { echo "::error::Secret '${SECRET_NAME}' is not set in this repo"; exit 1; }

          # Single-line Python (no leading spaces, no heredoc)
          ENC_VALUE="$(python3 -c "import os,base64; from nacl.public import PublicKey,SealedBox; pk=PublicKey(base64.b64decode(os.environ['PUBKEY'])); val=os.environ['SECRET_VALUE'].encode('utf-8'); print(base64.b64encode(SealedBox(pk).encrypt(val)).decode('ascii'))")"

          curl -sS -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${TARGET_OWNER}/${TARGET_REPO}/actions/secrets/${SECRET_NAME}" \
            -d "$(jq -nc --arg ev "$ENC_VALUE" --arg kid "$KEY_ID" '{encrypted_value:$ev, key_id:$kid}')" \
          | jq .
