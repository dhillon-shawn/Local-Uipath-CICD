name: Bootstrap an existing Repo (w Studio Project)

on:
  workflow_dispatch:
    inputs:
      repo_name:
        description: "Target repo name"
        required: true

      reviewers:
        description: "GitHub usernames for prod reviewers"
        required: false

      folder_name:
        description: "New Projects - FullyQualified Folder Name - Ex: Grandma/Mom/Daughter (creates Daughter SubFolder) or Orphan (Creates Standalone Folder)"
        default: ''
        required: false
permissions:
  write-all

env:
  scope: "OR.Folders OR.BackgroundTasks OR.TestSets OR.TestSetExecutions OR.TestSetSchedules OR.Settings.Read OR.Robots.Read OR.Machines OR.Execution OR.Assets OR.Users.Read OR.Jobs OR.Monitoring OR.Robots"

jobs:
  BOOTSTRAP:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout controller repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Mint App installation token
        id: inst
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.WORKFLOW_APP_ID }}
          private_key: ${{ secrets.WORKFLOW_PEM }}

      - name: Export App token
        run: echo "GH_TOKEN=${{ steps.inst.outputs.token }}" >> $GITHUB_ENV

      - name: Get Default Branch
        id: get_default
        env:
          REPO: ${{ inputs.repo_name}}
        run: |
          default_branch=$(
            curl -sSf -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository_owner }}/$REPO" | jq -r '.default_branch'
          )
          echo "Default Branch: $default_branch"
          echo "DEFAULT_BRANCH=$default_branch" >> $GITHUB_OUTPUT

      - name: check
        run: |
          echo "${{ steps.get_default.outputs.DEFAULT_BRANCH }} "

      - name: Repo Level (update default; enforce .github on non-prod)
        env:
          repo: ${{ inputs.repo_name }}
          default_branch: ${{ steps.get_default.outputs.DEFAULT_BRANCH }}
          non_prod_branch: non-prod
        run: |
          set -euo pipefail

          git clone --depth=1 "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository_owner }}/${repo}"
          cd "$(basename "$repo")"

          git config --global --add safe.directory "$(pwd)"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # -------------------------
          # 1) Update DEFAULT branch
          # -------------------------
          git switch "${default_branch}"
          git pull --ff-only origin "${default_branch}"

          mkdir -p .github/workflows
          cp "$GITHUB_WORKSPACE/templates/Issues/issue.yml"             .github/workflows/
          cp -r "$GITHUB_WORKSPACE/templates/Issues/ISSUE_TEMPLATE"     .github/
          cp "$GITHUB_WORKSPACE/templates/PRs/pull_request_template.md" .github/
          cp -r "$GITHUB_WORKSPACE/templates/PRs/PULL_REQUEST_TEMPLATE" .github/
          cp "$GITHUB_WORKSPACE/templates/CICD.yml"                     .github/workflows/

          git add .github
          if ! git diff --cached --quiet; then
            git commit -m "[BOT] - bootstrap/update .github"
            if ! git push origin "${default_branch}"; then
              echo "::notice:: push to ${default_branch} blocked (protected?) – continuing."
            fi
          else
            echo "No changes for ${default_branch}."
          fi
          
          if [[ -f "./project.json" ]]; then
            PID="$(jq -er '.name' ./project.json)"
            echo "PID=$PID" >> "$GITHUB_ENV"
            echo "Project ID: $PID"
          fi
          
          DEFAULT_HEAD="$(git rev-parse HEAD)"
          # Ensure we have the remote-tracking ref even in shallow clones
          git fetch --prune origin "+refs/heads/${non_branch}:refs/remotes/origin/${non_branch}" || true
          if git ls-remote --exit-code origin "refs/heads/${non_branch}" >/dev/null 2>&1; then
            # Create/update local branch to match remote tip
            if git rev-parse --verify "${non_branch}" >/dev/null 2>&1; then
              git switch "${non_branch}"
              git reset --hard "origin/${non_branch}"
            else
              git switch -C "${non_branch}" "origin/${non_branch}"
            fi
          else
            echo "Creating ${non_branch} from ${default_branch}…"
            git switch -C "${non_branch}" "${default_branch}"
            git push -u origin "${non_branch}"
          fi
          # Overwrite ONLY .github with the exact tree from DEFAULT_HEAD
          git rm -r --ignore-unmatch .github
          git restore -s "${DEFAULT_HEAD}" -- .github
          if ! git diff --quiet; then
            git add .github
            git commit -m "Sync .github from ${default_branch} on ${non_branch}"
            git push origin "${non_branch}"
          else
            echo "${non_branch} already has desired .github."
          fi



      - name: protect non-prod
        env:
          REPO: ${{ inputs.repo_name }}
        run: |
          echo "Protecting Non-Prod"          
          response=$(curl -sSf -X PUT \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/$REPO/branches/non-prod/protection" \
            -d '{
              "required_status_checks": null,
              "enforce_admins": false,
              "required_pull_request_reviews": null,
              "restrictions": null
            }'
          )
          echo "Response $response"


      - name: Protect default branch with a ruleset
        env:
          REPO: ${{ inputs.repo_name }}
          default_branch: ${{ steps.get_default.outputs.DEFAULT_BRANCH }}
          WORKFLOW_APP_ID: ${{ secrets.WORKFLOW_APP_ID }}
        run: |
          set -euo pipefail

          # Build minimal, valid payload (no heredocs; no fancy jq conditionals)
          payload="$(
            jq -nc \
              --arg name "Protect ${default_branch}" \
              --arg ref  "refs/heads/${default_branch}" \
              --arg appId "${WORKFLOW_APP_ID}" '
              {
                name: $name,
                target: "branch",
                enforcement: "active",
                conditions: { ref_name: { include: [ $ref ], exclude: [] } },
                bypass_actors: [
                  { actor_id: ($appId|tonumber), actor_type: "Integration", bypass_mode: "always" }
                ],
                rules: [
                  {
                    type: "pull_request",
                    parameters: {
                      required_approving_review_count: 1,
                      dismiss_stale_reviews_on_push: true,
                      require_code_owner_review: false,
                      require_last_push_approval: true,
                      required_review_thread_resolution: true
                    }
                  }
                ]
              }'
          )"

          response=$(curl -sS  -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/${REPO}/rulesets" \
            -d "${payload}"
          )
          echo "Re: $response"



      - name: turn on auto merge and delete on merge
        env:
          REPO: ${{ inputs.repo_name }}
        run: |
          curl -L -sSf \
            -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository_owner }}/$REPO" \
            -d '{"allow_auto_merge": true, "delete_branch_on_merge": true}'



      - name: Parse reviewers → numeric IDs (for prod env gate)
        id: parse_reviewers
        env:
          REVIEWERS: ${{ inputs.reviewers }}
        run: |
          set -euo pipefail
          users=$(echo "$REVIEWERS" | tr ', ' '\n' | sed '/^$/d' | sort -u)
          ids=()
          for u in $users; do
            id=$(gh api "users/$u" --jq .id || echo "")
            [ -n "$id" ] && ids+=("$id")
          done
          echo "gh_ids=$(IFS=,; echo "${ids[*]}")" >> $GITHUB_OUTPUT



      - name: Auth
        if: inputs.folder_name == ''
        uses: ./.github/actions/auth
        with:
                env: "DEV"
                role_arn: ${{ secrets.RPA_UIPATH_CICD_ROLE_ARN }}
                aws_region: "us-west-2"
                secret_id: ${{ secrets.RPA_UIPATH_CICD_SECRET_ARN }}
                scopes: ${{ env.scope }}



      - name: Scavenge Folder
        if: inputs.folder_name == ''
        run: |
            echo "Iterating through folder checking releases for a Process ID (${{ env.PID }}) match"

            FOLDERS=$(curl --location \
              --header "Authorization: Bearer $OR_TOKEN" \
              "${{ env.OR_URL }}/odata/Folders?\$select=Id,FullyQualifiedName"
            )

            echo "Folders Response: $FOLDERS"

            FOUND_FOLDER=""
            while IFS=$'\t' read -r fid fname || [ -n "$fid" ]; do

              fid=${fid%$'\r'}
              fname=${fname%$'\r'}

              [ -n "$fid" ] || continue
              echo "Checking folder: $fname ($fid)"

              response=$(curl --location \
                --header "Authorization: Bearer $OR_TOKEN" \
                --header "X-UIPATH-OrganizationUnitId: $fid" \
                "${{ env.OR_URL }}/odata/Releases?%24select=Id%2CProcessKey%2CName%2CProcessType&%24filter=ProcessKey%20eq%20%27${{ env.PID }}%27"
              )
              echo "Release Response: $response"

              id_found=$(printf '%s' "$response" | jq -r '.value[0].Id // empty')
              if [ -n "$id_found" ]; then
                echo "Found Release ID: $id_found in folder $fname ($fid)"
                FOUND_FOLDER="$fname"
                break
              fi
            done < <(
              printf '%s' "$FOLDERS" \
              | jq -r '.value[] | [.Id, (.FullyQualifiedName // "")] | @tsv' \
              | tr -d '\r'
            )

            if [ -n "$FOUND_FOLDER" ]; then
              echo "FOUND_FOLDER=$FOUND_FOLDER" >> "$GITHUB_ENV"
            else
              echo "::error::No folder with a matching Release (Process ID == ${{ env.PID }}) was found."
              exit 1
            fi
            
      - name: Resolve folder
        env:
          folder_name: ${{ inputs.folder_name }}
        run: |
          set -euo pipefail

          FOLDER_NAME="${folder_name:-}"
          if [ -z "${FOLDER_NAME}" ]; then
            FOLDER_NAME="${FOUND_FOLDER:-}"
          fi

          echo "Will set FOLDER_NAME='${FOLDER_NAME}'"
          echo "FOLDER_TO_SET=${FOLDER_NAME}" >> "$GITHUB_ENV"
          


      - name: Create/update environments + vars (uses App token)
        env:
          REPO: ${{ inputs.repo_name }}
          REVIEWER_IDS: ${{ steps.parse_reviewers.outputs.gh_ids }}
        run: |
          set -euo pipefail

          for env in dev test prod hotfix; do
              echo "Creating $env" 
              reviewers_block="$(
                jq -nc --arg ids "$REVIEWER_IDS" --arg env "$env" '
                  if $env == "prod" and ($ids|length>0) then
                    ($ids
                    | split(",")
                    | map(select(length>0) | tonumber)
                    | map({type:"User", id:.}))
                  else
                    []
                  end
                '
              )"

              payload="$(jq -nc --argjson reviewers "$reviewers_block" '
                {
                  wait_timer: 0,
                  reviewers: $reviewers
                }
              ')"

              echo "Payload: $payload"

              curl  -X PUT \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository_owner }}/$REPO/environments/$env" \
              -d "$payload"


              echo "==================="            
              echo "$env created"
              echo "==================="
             
              VARIABLES_JSON='{
                "dev": {
                  "MID": "",
                  "DEV_RID": "6144536",
                  "DEV_UID": "12616150",
                  "BOT_UID": "",
                  "BOT_RID": "6144535",
                  "FOLDER_NAME" : "${{ env.FOLDER_TO_SET}}"
                },
                "test": {
                  "MID": "5296531",
                  "DEV_RID": "6951189",
                  "DEV_UID": "12506499",
                  "BOT_UID": "12507013",
                  "BOT_RID": "6144537",
                  "FOLDER_NAME" : "${{ env.FOLDER_TO_SET}}"
                },
                "prod": {
                  "MID": "",
                  "DEV_RID": "6144536",
                  "DEV_UID": "12616150",
                  "BOT_UID": "",
                  "BOT_RID": "6144535",
                  "FOLDER_NAME" : "${{ env.FOLDER_TO_SET}}"
                },
                "hotfix": {
                  "MID": "",
                  "DEV_RID": "6144536",
                  "DEV_UID": "12616150",
                  "BOT_UID": "",
                  "BOT_RID": "6144535",
                  "FOLDER_NAME" : "${{ env.FOLDER_TO_SET}}"
                }
              }'

              echo "Creating or updating environment vars for $env"

              while IFS=$'\t' read -r name value; do
                payload_create=$(jq -nc --arg name "$name" --arg value "$value" '{name:$name, value:$value}')
                payload_update=$(jq -nc --arg value "$value" '{value:$value}')
                
                code=$(curl -sS -o /dev/null -w "%{http_code}" -X POST \
                  -H "Authorization: Bearer $GH_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  -H "Content-Type: application/json" \
                  "https://api.github.com/repos/${{ github.repository_owner }}/$REPO/environments/$env/variables" \
                  -d "$payload_create")

                if [[ "$code" == "201" ]]; then
                  echo "Created: $name"
                elif [[ "$code" == "409" || "$code" == "422" ]]; then
                  curl -sS -o /dev/null -X PATCH \
                    -H "Authorization: Bearer $GH_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    -H "Content-Type: application/json" \
                    "https://api.github.com/repos/${{ github.repository_owner }}/$REPO/environments/$env/variables/$name" \
                    -d "$payload_update"
                  echo "Updated: $name"
                else
                  echo "POST $name failed with HTTP $code" >&2
                  exit 1
                fi
              done < <(
                echo "$VARIABLES_JSON" \
                | jq -r --arg env "$env" '.[$env] // {} | to_entries[] | "\(.key)\t\(.value)"'
              )
          done
          
      - name: PRINT RESULTS - UPDATE
        run: |
            echo " "
            echo "====================================================================================="
            echo "Link to existing repo: https://github.com/${{ github.repository_owner }}/${{inputs.repo_name}}"
            echo "====================================================================================="
            echo " "




  copy:
    runs-on: ubuntu-latest
    needs: [BOOTSTRAP]
    env:
      TOKEN: ${{ secrets.USER_PAT }}
      TARGET_OWNER: ${{ github.repository_owner }}
      TARGET_REPO: ${{ inputs.repo_name }}
    strategy:
      matrix:
        name:
          [
            EMAIL_USERNAME,
            EMAIL_PASSWORD
          ]

    steps:
      - name: Get destination repo public key
        run: |
          set -e
          KEY_RESP="$(curl -sS \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${TARGET_OWNER}/${TARGET_REPO}/actions/secrets/public-key")"
          echo "$KEY_RESP" | jq .
          echo "KEY_ID=$(echo "$KEY_RESP" | jq -r .key_id)" >> "$GITHUB_ENV"
          echo "PUBKEY=$(echo "$KEY_RESP" | jq -r .key)"    >> "$GITHUB_ENV"

      - name: Install PyNaCl
        run: python3 -m pip install --quiet pynacl

      - name: Encrypt & upload ${{ matrix.name }}
        env:
          SECRET_NAME: ${{ matrix.name }}
          SECRET_VALUE: ${{ secrets[matrix.name] }}
        run: |
          set -euo pipefail
          [ -n "${SECRET_VALUE:-}" ] || { echo "::error::Secret '${SECRET_NAME}' is not set in this repo"; exit 1; }

          # Single-line Python (no leading spaces, no heredoc)
          ENC_VALUE="$(python3 -c "import os,base64; from nacl.public import PublicKey,SealedBox; pk=PublicKey(base64.b64decode(os.environ['PUBKEY'])); val=os.environ['SECRET_VALUE'].encode('utf-8'); print(base64.b64encode(SealedBox(pk).encrypt(val)).decode('ascii'))")"

          curl -sS -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${TARGET_OWNER}/${TARGET_REPO}/actions/secrets/${SECRET_NAME}" \
            -d "$(jq -nc --arg ev "$ENC_VALUE" --arg kid "$KEY_ID" '{encrypted_value:$ev, key_id:$kid}')" \
          | jq .


