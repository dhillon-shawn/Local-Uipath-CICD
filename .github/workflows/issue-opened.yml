name: Issue → Branch + PR

on:
  workflow_call:

permissions:
  write-all

concurrency:
  group: issue-${{ github.event.issue.number }}
  cancel-in-progress: false


jobs:

  parse:

    runs-on: ubuntu-latest
    steps:
        - name: Create branch + PR, link & assign, then comment (API-only, idempotent)
          uses: actions/github-script@v7
          with:
            script: |
              const repo = context.repo;
              const issue = context.payload.issue;
              const labels = issue.labels.map(l => typeof l === 'string' ? l : l.name);
              const has = (n) => labels.includes(n);

              // Decide type (priority: hotfix > library > process)
              let type, prefix, draft;
              if (has('hotfix'))      { type='hotfix';  prefix='hotfix';  draft=false; }
              else if (has('library')){ type='library'; prefix='library'; draft=true;  }
              else if (has('process')){ type='process'; prefix='release'; draft=true;  }
              else return; // not one of the three → exit quietly

              // Branch: <prefix>/<issue-number>-<slug>
              const slug = (issue.title||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'').replace(/-+/g,'-');
              const branch = `${prefix}/${issue.number}-${slug}`;

              // Base ref
              const defaultBranch = context.payload.repository.default_branch;
              const baseRef = await github.rest.git.getRef({ ...repo, ref: `heads/${defaultBranch}` });
              const baseSha = baseRef.data.object.sha;

              // Ensure branch exists
              let headSha = baseSha;
              try {
                const r = await github.rest.git.getRef({ ...repo, ref: `heads/${branch}` });
                headSha = r.data.object.sha;
              } catch {
                await github.rest.git.createRef({ ...repo, ref: `refs/heads/${branch}`, sha: baseSha });
              }

              // Ensure one empty init commit on branch (diff-less)
              const initMsg = `chore(${type}): initialize (#${issue.number})`;
              const headCommit = await github.rest.git.getCommit({ ...repo, commit_sha: headSha });
              if (headCommit.data.message !== initMsg) {
                const newCommit = await github.rest.git.createCommit({
                  ...repo, message: initMsg, tree: headCommit.data.tree.sha, parents: [headSha]
                });
                await github.rest.git.updateRef({ ...repo, ref: `heads/${branch}`, sha: newCommit.data.sha, force: false });
              }

              // Create or find PR (include auto-close keyword)
              const prTitle = `${issue.title} (#${issue.number})`;
              const prBody  = [`Closes #${issue.number}`, `Type: ${type}`, '', '---', '', issue.body || ''].join('\n');
              const headRef = `${repo.owner}:${branch}`;
              let pr = (await github.rest.pulls.list({ ...repo, state: 'open', head: headRef })).data[0];
              if (!pr) {
                pr = (await github.rest.pulls.create({
                  ...repo, title: prTitle, head: branch, base: defaultBranch, body: prBody, draft
                })).data;
              } else if (!(pr.body||'').includes(`Closes #${issue.number}`)) {
                await github.rest.pulls.update({ ...repo, pull_number: pr.number, body: prBody });
              }

              // Assignees: ensure the issue has one (reporter) and mirror to PR
              const want = new Set((issue.assignees||[]).map(a=>a.login).filter(Boolean));
              if (!want.size && issue.user?.login) want.add(issue.user.login);
              const assignees = [...want];
              if (assignees.length) {
                try { await github.rest.issues.addAssignees({ ...repo, issue_number: issue.number, assignees }); } catch {}
                try { await github.rest.issues.addAssignees({ ...repo, issue_number: pr.number, assignees }); } catch {}
              }

              // Comment meta back on the issue (once)
              const meta = {
                pr: pr.number, pr_url: pr.html_url,
                branch: pr.head.ref, base: pr.base.ref,
                issue: issue.number, source_head_sha: pr.head.sha,
                slug, created_by: context.actor, created_at: new Date().toISOString()
              };
              const commentBody = [
                `Opened PR: ${pr.html_url}`,
                `Branch: \`${pr.head.ref}\``,
                '',
                '<!-- pr-meta:',
                JSON.stringify(meta),
                '-->'
              ].join('\n');

              const comments = await github.rest.issues.listComments({ ...repo, issue_number: issue.number, per_page: 50 });
              const exists = comments.data.some(c => (c.body||'').includes('<!-- pr-meta:') && (c.body||'').includes(`"pr": ${pr.number}`));
              if (!exists) await github.rest.issues.createComment({ ...repo, issue_number: issue.number, body: commentBody });
