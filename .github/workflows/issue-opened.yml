name: Issue â†’ Branch + PR

on:
  workflow_call:

permissions:
  write-all

concurrency:
  group: issue-${{ github.event.issue.number }}
  cancel-in-progress: false


jobs:

  parse:

    runs-on: ubuntu-latest
    steps:

      - uses: actions/checkout@v4

      - name: Decide routing
        id: meta
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(l => typeof l === 'string' ? l : l.name);
            const has = (n) => labels.includes(n);

            let type, prefix, draft;
            if (has('hotfix'))      { type='hotfix';  prefix='hotfix';  draft=false; }
            else if (has('library')){ type='library'; prefix='library'; draft=true;  }
            else if (has('process')){ type='process'; prefix='release'; draft=true;  }
            else { core.setOutput('proceed','false'); return; }

            const slug = (issue.title||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'').replace(/-+/g,'-');
            core.setOutput('proceed','true');
            core.setOutput('type', type);
            core.setOutput('draft', String(draft));
            core.setOutput('slug', slug);
            core.setOutput('branch', `${prefix}/${issue.number}-${slug}`);
            core.setOutput('base', context.payload.repository.default_branch);

      - name: Stop if not applicable
        if: steps.meta.outputs.proceed != 'true'
        run: echo "No matching template labels; exiting."

      # 2) Ensure branch + a single empty init commit
      - name: Ensure branch + empty commit
        if: steps.meta.outputs.proceed == 'true'
        id: branch
        uses: actions/github-script@v7
        with:
          script: |
            const repo   = context.repo;
            const issue  = context.payload.issue;
            const branch = '${{ steps.meta.outputs.branch }}';
            const base   = '${{ steps.meta.outputs.base }}';
            const type   = '${{ steps.meta.outputs.type }}';

            const { data: baseRef } = await github.rest.git.getRef({ ...repo, ref: `heads/${base}` });
            const baseSha = baseRef.object.sha;

            let headSha = baseSha;
            try {
              const r = await github.rest.git.getRef({ ...repo, ref: `heads/${branch}` });
              headSha = r.data.object.sha;
            } catch {
              await github.rest.git.createRef({ ...repo, ref: `refs/heads/${branch}`, sha: baseSha });
            }

            const initMsg = `chore(${type}): initialize (#${issue.number})`;
            const headCommit = await github.rest.git.getCommit({ ...repo, commit_sha: headSha });
            if (headCommit.data.message !== initMsg) {
              const newCommit = await github.rest.git.createCommit({
                ...repo, message: initMsg, tree: headCommit.data.tree.sha, parents: [headSha]
              });
              await github.rest.git.updateRef({ ...repo, ref: `heads/${branch}`, sha: newCommit.data.sha, force: false });
            }

      # 3) Create or update the PR (collapsible issue body + Closes #)
      - name: Create/update PR
        if: steps.meta.outputs.proceed == 'true'
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const repo   = context.repo;
            const issue  = context.payload.issue;
            const branch = '${{ steps.meta.outputs.branch }}';
            const base   = '${{ steps.meta.outputs.base }}';
            const type   = '${{ steps.meta.outputs.type }}';
            const draft  = '${{ steps.meta.outputs.draft }}' === 'true';

            const title = `issue: #${issue.number} - ${issue.title}`;
            const body  = [
              `Closes #${issue.number}`,
              `Type: ${type}`,
              '',
              '---',
              '',
              '<details>',
              '<summary><strong>Issue body</strong></summary>',
              '',
              issue.body || '_No description provided._',
              '',
              '</details>'
            ].join('\n');

            const headRef = `${repo.owner}:${branch}`;
            let pr = (await github.rest.pulls.list({ ...repo, state: 'open', head: headRef })).data[0];

            if (!pr) {
              pr = (await github.rest.pulls.create({ ...repo, title, head: branch, base, body, draft })).data;
            } else if ((pr.body||'') !== body) {
              await github.rest.pulls.update({ ...repo, pull_number: pr.number, body });
            }

            core.setOutput('number', String(pr.number));

      # 4) Sync labels + milestone
      - name: Sync labels & milestone
        if: steps.meta.outputs.proceed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const issue = context.payload.issue;
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            if (!prNumber) return;

            const labels = issue.labels.map(l => typeof l === 'string' ? l : l.name);
            if (labels.length) await github.rest.issues.addLabels({ ...repo, issue_number: prNumber, labels }).catch(()=>{});
            if (issue.milestone) await github.rest.issues.update({ ...repo, issue_number: prNumber, milestone: issue.milestone.number }).catch(()=>{});

      # 5) Ensure assignees on issue (fallback to author) and mirror to PR
      - name: Ensure & mirror assignees
        if: steps.meta.outputs.proceed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const issue = context.payload.issue;
            const prNumber = Number('${{ steps.pr.outputs.number }}');

            const desired = new Set((issue.assignees||[]).map(a=>a.login).filter(Boolean));
            if (!desired.size && issue.user?.login) desired.add(issue.user.login);
            const assignees = [...desired];
            if (!assignees.length) return;

            await github.rest.issues.addAssignees({ ...repo, issue_number: issue.number, assignees }).catch(()=>{});
            if (prNumber) await github.rest.issues.addAssignees({ ...repo, issue_number: prNumber, assignees }).catch(()=>{});

      # 6) Comment meta on the issue (once)
      - name: Comment PR meta on issue
        if: steps.meta.outputs.proceed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const issue = context.payload.issue;
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            if (!prNumber) return;

            const { data: pr } = await github.rest.pulls.get({ ...repo, pull_number: prNumber });
            const meta = {
              pr: pr.number,
              pr_url: pr.html_url,
              branch: pr.head.ref,
              base: pr.base.ref,
              issue: issue.number,
              source_head_sha: pr.head.sha,
              slug: '${{ steps.meta.outputs.slug }}',
              created_by: context.actor,
              created_at: new Date().toISOString()
            };

            const body = [
              `Opened PR: ${pr.html_url}`,
              `Branch: \`${pr.head.ref}\``,
              '',
              '<!-- pr-meta:',
              JSON.stringify(meta),
              '-->'
            ].join('\n');

            const comments = await github.rest.issues.listComments({ ...repo, issue_number: issue.number, per_page: 50 });
            const exists = comments.data.some(c => (c.body||'').includes('<!-- pr-meta:') && (c.body||'').includes(`"pr": ${pr.number}`));
            if (!exists) await github.rest.issues.createComment({ ...repo, issue_number: issue.number, body });

      - name: Parse Issue Form
        id: parse
        uses: edumserrano/github-issue-forms-parser@v1
        with:
          template-filepath: '.github/ISSUE_TEMPLATE/process.yml'
          issue-form-body: '${{ github.event.issue.body }}'

      - name: Compose API payload
        id: compose
        shell: bash
        env:
          FORM_JSON: ${{ steps.parse.outputs.parsed-issue }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
        run: |
          echo "$FORM_JSON" > form.json
          NOW=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          PAYLOAD=$(jq -c --arg title "$ISSUE_TITLE" --arg now "$NOW" '
            def yesno($b): if $b then "Yes" else "No" end;

            . as $f |
            {
              "category": "Software",
              "business_service": "UiPath",
              "type": "Normal",
              "assignment_group": "ISD EAB: Intelligent Automation Product (IAP) Unit ",
              "u_environment": "Production",
              "u_nagios_alerts": "No",
              "u_sos_impact": "No",
              "u_new_app_system": "No",
              
              "u_public_impact":               yesno($f.checklist["Impacts the public."]),
              "u_does_change_invovle_a_vedor": yesno($f.checklist["Impact a Vendors."]),
              "u_involve_cdt":                 yesno($f.checklist["Involves CDT."]),
              "u_new_app_esd":                 yesno($f.checklist["New app (ESD needs to know)."]),

              "backout_plan":        $f.backout_plan,
              "implementation_plan": $f.implementation_plan,
              "validation_plan":     $f.validation_plan,

              "assigned_to":         $f.requester_email,
              "u_effort_project":    $f.effort,

              "description":         $f.description,
              "short_description":   ("Prod - " + $title),
              "business_value":      $f.business_value,

              "cab_delegate":        $f.backup_contact,
              "u_impacted_users":    $f.impacted_groups,

              "u_who_was_notified":          $f.impacted_users_emails,
              "impacted_users_emails":       $f.impacted_users_emails,
              "u_impacted_user_notify_date": $f.last_notified_when,
              "u_how_impacted_notified":     $f.last_notified_how,

              "start_date": $now,
              "end_date":   $f.target_end_date
            }
          ' form.json)

          echo "payload=$PAYLOAD" >> "$GITHUB_OUTPUT"
          echo "$PAYLOAD" > payload.json
