name: Central Pipeline

on:
  workflow_call:
    inputs:
      target_env:
        type: string
        required: true
      source_ref:
        type: string
        required: true
    secrets: {}
env:
  scope: "OR.Assets OR.BackgroundTasks OR.Execution OR.Folders OR.Jobs OR.Machines.Read OR.Monitoring OR.Robots.Read OR.Settings.Read OR.TestSets OR.TestSetExecutions OR.TestSetSchedules OR.Users.Read"

jobs:
  setup:
    name: setup (routing, mapping, manifests)
    environment: ${{ inputs.target_env }}
    runs-on: ubuntu-latest
    outputs:
      pid:                  ${{ steps.setup.outputs.PID }}
      ptype:                ${{ steps.setup.outputs.ptype }}
      entry_point:          ${{ steps.setup.outputs.entry_point }}
      deployment_matrix:          ${{ steps.setup.outputs.deployment_matrix }}
      email:                ${{ steps.setup.outputs.EMAIL }}
      publishable:          ${{ steps.setup.outputs.PUBLISHABLE }}

      pr_number:            ${{ steps.setup.outputs.PR_NUMBER }}
      pr_action:            ${{ steps.setup.outputs.PR_ACTION }}
      migrate:              ${{ steps.setup.outputs.MIGRATE }}

      vars: ${{ steps.capture.outputs.vars_json }}

      notes: ${{ steps.notes.outputs.release_text }}

    steps:
      - name: Checkout exact source ref
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.source_ref }}
          persist-credentials: true

      - name: Capture environment and repo vars
        id: capture
        run: |
          echo "vars_json<<EOF" >> "$GITHUB_OUTPUT"
          echo '${{ toJSON(vars) }}' >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

  #    - name: Print vars
  #      run: echo "${{ steps.capture.outputs.vars_json }}"

      - name: Pipeline Setup (Parse+Set)
        id: setup
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/setup@main
        with:
          target_env:  ${{ inputs.target_env }}
          source_ref:  ${{ inputs.source_ref }}
          vars:        ${{ steps.capture.outputs.vars_json }}

      - name: create and format release notes
        id: notes
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/release_notes@main


      - name: PRINT NOTES
        run: |
                echo "NOTES: ${{ steps.notes.outputs.release_text }}"



# ==================================================================================================
# Deps
# ==================================================================================================
  resolve-dependencies:
    name: prepare (auth → version → folder → assets/libs)
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      version:       ${{ steps.compute.outputs.version }}
      base_folder_name:   ${{ steps.folder.outputs.base_folder_name }}
      fid: ${{ steps.folder.outputs.fid }}
    steps:
      - name: Checkout exact source ref
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.source_ref }}
          persist-credentials: true

      - name: auth
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/auth@main
        with:
                target_env: ${{ inputs.target_env == 'hotfix' && 'prod' || inputs.target_env }}
                role_arn: ${{ secrets.RPA_UIPATH_CICD_ROLE_ARN }}
                aws_region: "us-west-2"
                secret_id: ${{ secrets.RPA_UIPATH_CICD_SECRET_ARN }}
                scopes: ${{ env.scope }}

      - id: compute
        name: Compute version
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/compute-version@main
        with:
          target_env:         ${{ inputs.target_env }}
          pid:                ${{ needs.setup.outputs.pid }}

      - id: folder
        name: Resolve / create folder
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/ensure-folder@main
        with:
          target_env:         ${{ inputs.target_env }}
          pid:                ${{ needs.setup.outputs.pid }}
          or_url:             ${{ env.OR_URL }}
          token:              $TOKEN
          dev_rid:            ${{ fromJSON(needs.setup.outputs.vars).DEV_RID }}
          bot_rid:            ${{ fromJSON(needs.setup.outputs.vars).BOT_RID }}
          mid:                ${{ fromJSON(needs.setup.outputs.vars).MID }}
          bot_uid:            ${{ fromJSON(needs.setup.outputs.vars).BOT_UID }}
          dev_uid:            ${{ fromJSON(needs.setup.outputs.vars).DEV_UID }}
          FOLDER_NAME:        "${{ fromJSON(needs.setup.outputs.vars).FOLDER_NAME }}"


      - name: Ensure assets (only on first promote / prod merge)
        if: ${{ needs.setup.outputs.migrate == 'true' }}
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/migrate-assets@main
        with:
          source_base_url:          ${{ env.BASE_URL }}
          TARGET_OR_URL:             ${{ env.OR_URL }}
          token:              $TOKEN


  CLI:
    runs-on: windows-latest
    needs: [setup, resolve-dependencies]
    steps:

      - name: auth
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/auth@main
        with:
                target_env: ${{ inputs.target_env == 'hotfix' && 'prod' || inputs.target_env }}
                role_arn: ${{ secrets.RPA_UIPATH_CICD_ROLE_ARN }}
                aws_region: "us-west-2"
                secret_id: ${{ secrets.RPA_UIPATH_CICD_SECRET_ARN }}
                scopes: ${{ env.scope }}

      - name: Checkout exact source ref (exclude .github)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.source_ref }}
          persist-credentials: true

      - name: Check UiPath CLI
        id: check-uipcli
        shell: powershell
        run: |
          $cmd = Get-Command uipcli -ErrorAction SilentlyContinue
          if ($cmd) {
            "has_uipcli=true"  >> $env:GITHUB_OUTPUT
            "uipcli_dir=$((Split-Path $cmd.Source -Parent))" >> $env:GITHUB_OUTPUT
            Write-Host "Found uipcli in $((Split-Path $cmd.Source -Parent))"
          } else {
            "has_uipcli=false" >> $env:GITHUB_OUTPUT
            Write-Host "uipcli not found on PATH"
          }

      - name: uipath-setup
        if: steps.check-uipcli.outputs.has_uipcli != 'true'
        uses: Mikael-RnD/setup-uipath@v2

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
        env:
          DOTNET_INSTALL_DIR: '${{ runner.temp }}/.dotnet'

      - name: set nuget.config
        shell: powershell
        run: |
          @'
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <!-- Feeds -->
            <packageSources>
              <clear />
              <add key="UiPath-Marketplace" value="https://gallery.uipath.com/api/v3/index.json" />
              <add key="Official"           value="https://pkgs.dev.azure.com/uipath/Public.Feeds/_packaging/UiPath-Official/nuget/v3/index.json" />
            </packageSources>
            <!-- Optional: keep in sync with MACHINE_NUGET_ROOT below
                NuGet honors NUGET_PACKAGES env first; this is a fallback -->
            <config>
              <add key="globalPackagesFolder" value="%ProgramData%\uipath\nuget\packages" />
            </config>
          </configuration>
          '@ | Set-Content -Path '${{ github.workspace }}\nuget.config' -Encoding UTF8

          $uipcli = (Get-Command uipcli).Source
          Copy-Item '${{ github.workspace }}\nuget.config' -Destination (Split-Path $uipcli -Parent) -Force


      - name: Configure NuGet cache roots
        id: cache-roots
        shell: powershell
        run: |
          $MACHINE_NUGET_ROOT = Join-Path $env:ProgramData 'uipath\nuget'
          $JOB_NUGET_ROOT     = Join-Path $env:RUNNER_TEMP  'nuget'

          New-Item -ItemType Directory -Force -Path `
            (Join-Path $MACHINE_NUGET_ROOT 'packages'),(Join-Path $MACHINE_NUGET_ROOT 'http'),`
            (Join-Path $JOB_NUGET_ROOT     'packages'),(Join-Path $JOB_NUGET_ROOT     'http') | Out-Null

          "MACHINE_NUGET_ROOT=$MACHINE_NUGET_ROOT" >> $env:GITHUB_OUTPUT
          "JOB_NUGET_ROOT=$JOB_NUGET_ROOT"         >> $env:GITHUB_OUTPUT

          # For the current job, point NuGet *at the JOB cache* (fast & isolated)
          "NUGET_PACKAGES=$JOB_NUGET_ROOT\packages"    >> $env:GITHUB_ENV
          "NUGET_HTTP_CACHE_PATH=$JOB_NUGET_ROOT\http" >> $env:GITHUB_ENV


      - name: Confirm NuGet folders
        shell: powershell
        run: |
          dotnet nuget locals all --list
          
#      - name: Confirm NuGet folders
#        shell: powershell
#        run: |
#          Write-Host "NUGET_PACKAGES=$env:NUGET_PACKAGES"
#          Write-Host "NUGET_HTTP_CACHE_PATH=$env:NUGET_HTTP_CACHE_PATH"
#          dotnet nuget locals all --list


      - name: Prime cache + depcheck
        id: depcheck
        shell: powershell
        env:
          MACHINE_NUGET_ROOT: ${{ steps.cache-roots.outputs.MACHINE_NUGET_ROOT }}
          # Optional: semicolon-separated extra roots, e.g. "D:\nuget\packages;E:\mirror\packages"
          EXTRA_NUGET_ROOTS: ''
        run: |
          $ErrorActionPreference = 'Stop'

          # ---- Helpers ------------------------------------------------------------
          function Normalize-VersionSpec {
            param([string]$Spec)
            $s = $Spec.Trim()
            # exact pinned version like [25.8.0] -> 25.8.0
            if ($s -match '^\[(?<v>[^\],\s]+)\]$') { return $Matches['v'] }
            # plain version like 25.8.0 -> 25.8.0
            if ($s -notmatch ',') { return $s }
            # ranges (contain comma) -> cannot be sure -> return $null to force restore
            return $null
          }

          function Get-CandidateRoots {
            param()
            $roots = New-Object System.Collections.Generic.List[string]
            # 1) Machine cache we manage
            $roots.Add( (Join-Path $env:MACHINE_NUGET_ROOT 'packages') )
            # 2) Default user cache (where NuGet usually puts them if no override)
            $userPkg = Join-Path $env:USERPROFILE '.nuget\packages'
            if (Test-Path $userPkg) { $roots.Add($userPkg) }
            # 3) Optional additional roots
            if ($env:EXTRA_NUGET_ROOTS) {
              $env:EXTRA_NUGET_ROOTS.Split(';') | ForEach-Object {
                $p = $_.Trim()
                if ($p) { $roots.Add($p) }
              }
            }
            return $roots
          }

          function Find-PackagePath {
            param([string]$Id,[string]$Version,[string[]]$Roots)
            $idLower = $Id.ToLower()
            foreach ($r in $Roots) {
              $idDirLower = Join-Path $r $idLower
              $idDirExact = Join-Path $r $Id
              $idDir = $null
              if (Test-Path $idDirLower) { $idDir = $idDirLower }
              elseif (Test-Path $idDirExact) { $idDir = $idDirExact }
              else { continue }

              $verDir = Join-Path $idDir $Version
              if (Test-Path $verDir) { return $verDir }
            }
            return $null
          }

          function Copy-PackageToJob {
            param([string]$Id,[string]$Version,[string]$SrcVerDir)
            $dstId  = Join-Path $env:NUGET_PACKAGES ($Id.ToLower())
            $dstVer = Join-Path $dstId $Version
            if (-not (Test-Path $dstId)) { New-Item -ItemType Directory -Force -Path $dstId | Out-Null }
            robocopy "$SrcVerDir" "$dstVer" /E /NFL /NDL /NJH /NJS /XO /XN /XC | Out-Null
            $rc = $LASTEXITCODE
            if ($rc -ge 8) { throw "robocopy failed with exit $rc while priming $Id@$Version" }
            Write-Host "robocopy exit $rc (OK): primed $Id@$Version"
            $global:LASTEXITCODE = 0
          }

          function Test-PackagePresentInJob {
            param([string]$Id,[string]$Version)
            $verDir = Join-Path (Join-Path $env:NUGET_PACKAGES ($Id.ToLower())) $Version
            if (-not (Test-Path $verDir)) { return $false }
            # If the folder exists AND has either metadata or sha512, we consider it installed
            $hasMarker = (Get-ChildItem -Path $verDir -Filter '*.nupkg.sha512' -ErrorAction SilentlyContinue |
                          Select-Object -First 1) -or
                        (Get-ChildItem -Path $verDir -Filter '*.nupkg.metadata' -ErrorAction SilentlyContinue |
                          Select-Object -First 1)
            return [bool]$hasMarker
          }
          # ------------------------------------------------------------------------

          $proj = Join-Path $env:GITHUB_WORKSPACE 'project.json'
          if (-not (Test-Path $proj)) { throw "project.json not found at $proj" }

          $json = Get-Content $proj -Raw | ConvertFrom-Json
          $depProps = @()
          if ($json.PSObject.Properties.Name -contains 'dependencies' -and $json.dependencies) {
            $depProps = $json.dependencies.PSObject.Properties
          }

          if (-not $depProps -or $depProps.Count -eq 0) {
            Write-Host "No 'dependencies' found; skipping restore."
            'needs_restore=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $roots = Get-CandidateRoots
          $missing = New-Object System.Collections.Generic.List[string]
          foreach ($p in $depProps) {
            $id = [string]$p.Name
            $spec = [string]$p.Value
            if ([string]::IsNullOrWhiteSpace($id) -or [string]::IsNullOrWhiteSpace($spec)) { continue }

            $ver = Normalize-VersionSpec $spec
            if (-not $ver) {
              # version ranges -> force restore
              $missing.Add("$id@$spec")
              continue
            }

            # If already in JOB cache, nothing to do
            if (Test-PackagePresentInJob -Id $id -Version $ver) { continue }

            # Try to find in any known root and copy it in
            $src = Find-PackagePath -Id $id -Version $ver -Roots $roots
            if ($src) {
              Copy-PackageToJob -Id $id -Version $ver -SrcVerDir $src
              if (Test-PackagePresentInJob -Id $id -Version $ver) { continue }
            }

            # Still missing
            $missing.Add("$id@$spec")
          }

          if ($missing.Count -gt 0) {
            "needs_restore=true"             | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "missing=$($missing -join ', ')" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Missing in JOB cache: $($missing -join ', ')"
          } else {
            "needs_restore=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "All deps present in JOB cache."
          }



      - name: restore
        if: steps.depcheck.outputs.needs_restore == 'true'
        shell: powershell
        env:
          NUGET_PACKAGES:        ${{ env.NUGET_PACKAGES }}        # JOB cache
          NUGET_HTTP_CACHE_PATH: ${{ env.NUGET_HTTP_CACHE_PATH }} # JOB cache
        run: |
          uipcli package restore '${{ github.workspace }}' `
            --restoreFolder '${{ env.NUGET_PACKAGES }}' `
            --nugetConfigFilePath '${{ github.workspace }}\nuget.config' `
            --libraryOrchestratorUrl '${{ env.BASE_URL }}/' `
            --libraryOrchestratorTenant '${{ env.TENANT }}' `
            -A '${{ env.ORG }}' -I '${{ env.APP_ID }}' -S '${{ env.APP_SECRET }}' `
            --libraryOrchestratorApplicationScope '${{ env.scope }}' `
            --disableBuiltInNugetFeeds `
            --libraryIdentityUrl '${{ env.BASE_URL }}/identity_' `
            -y --traceLevel "Verbose"
            

      - name: Backfill machine cache
        if: steps.depcheck.outputs.needs_restore == 'true'
        shell: powershell
        env:
          MACHINE_NUGET_ROOT: ${{ steps.cache-roots.outputs.MACHINE_NUGET_ROOT }}
        run: |
          $src = $env:NUGET_PACKAGES
          $dst = Join-Path $env:MACHINE_NUGET_ROOT 'packages'
          if (-not (Test-Path $dst)) { New-Item -ItemType Directory -Force -Path $dst | Out-Null }

          robocopy "$src" "$dst" /E /NFL /NDL /NJH /NJS /XO /XN /XC | Out-Null
          $rc = $LASTEXITCODE
          if ($rc -ge 8) { throw "robocopy failed with exit $rc during backfill" }
          Write-Host "robocopy exit $rc (OK) : backfilled machine cache."
          $global:LASTEXITCODE = 0


      - name: Create Results DIR
        shell: powershell
        run: New-Item -Path "./results" -ItemType Directory -Force | Out-Null


      - name: Confirm NuGet folders
        shell: powershell
        run: |
          dotnet nuget locals all --list

          
      - name: post  depcheck
        shell: powershell
        env:
          MACHINE_NUGET_ROOT: ${{ steps.cache-roots.outputs.MACHINE_NUGET_ROOT }}
          # Optional: semicolon-separated extra roots, e.g. "D:\nuget\packages;E:\mirror\packages"
          EXTRA_NUGET_ROOTS: ${{ env.EXTRA_NUGET_ROOTS }}
        run: |
          $ErrorActionPreference = 'Stop'

          # ---- Helpers ------------------------------------------------------------
          function Normalize-VersionSpec {
            param([string]$Spec)
            $s = $Spec.Trim()
            # exact pinned version like [25.8.0] -> 25.8.0
            if ($s -match '^\[(?<v>[^\],\s]+)\]$') { return $Matches['v'] }
            # plain version like 25.8.0 -> 25.8.0
            if ($s -notmatch ',') { return $s }
            # ranges (contain comma) -> cannot be sure -> return $null to force restore
            return $null
          }

          function Get-CandidateRoots {
            param()
            $roots = New-Object System.Collections.Generic.List[string]
            # 1) Machine cache we manage
            $roots.Add( (Join-Path $env:MACHINE_NUGET_ROOT 'packages') )
            # 2) Default user cache (where NuGet usually puts them if no override)
            $userPkg = Join-Path $env:USERPROFILE '.nuget\packages'
            if (Test-Path $userPkg) { $roots.Add($userPkg) }
            # 3) Optional additional roots
            if ($env:EXTRA_NUGET_ROOTS) {
              $env:EXTRA_NUGET_ROOTS.Split(';') | ForEach-Object {
                $p = $_.Trim()
                if ($p) { $roots.Add($p) }
              }
            }
            return $roots
          }

          function Find-PackagePath {
            param([string]$Id,[string]$Version,[string[]]$Roots)
            $idLower = $Id.ToLower()
            foreach ($r in $Roots) {
              $idDirLower = Join-Path $r $idLower
              $idDirExact = Join-Path $r $Id
              $idDir = $null
              if (Test-Path $idDirLower) { $idDir = $idDirLower }
              elseif (Test-Path $idDirExact) { $idDir = $idDirExact }
              else { continue }

              $verDir = Join-Path $idDir $Version
              if (Test-Path $verDir) { return $verDir }
            }
            return $null
          }

          function Copy-PackageToJob {
            param([string]$Id,[string]$Version,[string]$SrcVerDir)
            $dstId  = Join-Path $env:NUGET_PACKAGES ($Id.ToLower())
            $dstVer = Join-Path $dstId $Version
            if (-not (Test-Path $dstId)) { New-Item -ItemType Directory -Force -Path $dstId | Out-Null }
            robocopy "$SrcVerDir" "$dstVer" /E /NFL /NDL /NJH /NJS /XO /XN /XC | Out-Null
            $rc = $LASTEXITCODE
            if ($rc -ge 8) { throw "robocopy failed with exit $rc while priming $Id@$Version" }
            Write-Host "robocopy exit $rc (OK): primed $Id@$Version"
            $global:LASTEXITCODE = 0
          }

          function Test-PackagePresentInJob {
            param([string]$Id,[string]$Version)
            $verDir = Join-Path (Join-Path $env:NUGET_PACKAGES ($Id.ToLower())) $Version
            if (-not (Test-Path $verDir)) { return $false }
            # If the folder exists AND has either metadata or sha512, we consider it installed
            $hasMarker = (Get-ChildItem -Path $verDir -Filter '*.nupkg.sha512' -ErrorAction SilentlyContinue |
                          Select-Object -First 1) -or
                        (Get-ChildItem -Path $verDir -Filter '*.nupkg.metadata' -ErrorAction SilentlyContinue |
                          Select-Object -First 1)
            return [bool]$hasMarker
          }
          # ------------------------------------------------------------------------

          $proj = Join-Path $env:GITHUB_WORKSPACE 'project.json'
          if (-not (Test-Path $proj)) { throw "project.json not found at $proj" }

          $json = Get-Content $proj -Raw | ConvertFrom-Json
          $depProps = @()
          if ($json.PSObject.Properties.Name -contains 'dependencies' -and $json.dependencies) {
            $depProps = $json.dependencies.PSObject.Properties
          }

          if (-not $depProps -or $depProps.Count -eq 0) {
            Write-Host "No 'dependencies' found; skipping restore."
            'needs_restore=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $roots = Get-CandidateRoots
          $missing = New-Object System.Collections.Generic.List[string]
          foreach ($p in $depProps) {
            $id = [string]$p.Name
            $spec = [string]$p.Value
            if ([string]::IsNullOrWhiteSpace($id) -or [string]::IsNullOrWhiteSpace($spec)) { continue }

            $ver = Normalize-VersionSpec $spec
            if (-not $ver) {
              # version ranges -> force restore
              $missing.Add("$id@$spec")
              continue
            }

            # If already in JOB cache, nothing to do
            if (Test-PackagePresentInJob -Id $id -Version $ver) { continue }

            # Try to find in any known root and copy it in
            $src = Find-PackagePath -Id $id -Version $ver -Roots $roots
            if ($src) {
              Copy-PackageToJob -Id $id -Version $ver -SrcVerDir $src
              if (Test-PackagePresentInJob -Id $id -Version $ver) { continue }
            }

            # Still missing
            $missing.Add("$id@$spec")
          }

          if ($missing.Count -gt 0) {
            "needs_restore=true"             | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "missing=$($missing -join ', ')" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Missing in JOB cache: $($missing -join ', ')"
          } else {
            "needs_restore=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "All deps present in JOB cache."
          }

          

      - name: analyze
        if: inputs.target_env == 'dev'
        shell: powershell
        env:
          NUGET_PACKAGES:        ${{ env.NUGET_PACKAGES }}
          NUGET_HTTP_CACHE_PATH: ${{ env.NUGET_HTTP_CACHE_PATH }}
        run: |
          uipcli package analyze '${{ github.workspace }}\project.json' `
            --resultPath '${{ runner.temp }}\analyze.json' `
            --orchestratorUrl '${{ env.BASE_URL }}/' `
            --orchestratorTenant '${{ env.TENANT }}' `
            -A '${{ env.ORG }}' -I '${{env.APP_ID  }}' -S '${{env.APP_SECRET}}' `
            --orchestratorApplicationScope '${{ env.scope}}' `
            --analyzerTraceLevel "Error" `
            --traceLevel Verbose --disableBuiltInNugetFeeds -y `
            --identityUrl '${{ env.BASE_URL }}/identity_'
                  
          New-Item -ItemType Directory -Force -Path '.\results' | Out-Null
          Copy-Item '${{ runner.temp }}\analyze.json' '.\results\analyze.json' -Force

      - name: stage for pack
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $stage = Join-Path $env:RUNNER_TEMP 'uipack-stage'
          if (Test-Path $stage) { Remove-Item -Recurse -Force $stage }
          New-Item -ItemType Directory -Path $stage | Out-Null

          robocopy "${{ github.workspace }}" "$stage" /MIR `
            /XD '.git' '.github' 'output' 'results' '.nuget-cache' '.nuget-http' '.nuget' `
            /XF '*.nupkg' 'nuget.config'

          $rc = $LASTEXITCODE
          if ($rc -ge 8) { throw "robocopy failed with exit $rc" } else { Write-Host "robocopy exit $rc (OK)"; exit 0 }

      - name: pack
        shell: powershell
        env:
          NUGET_PACKAGES:        ${{ env.NUGET_PACKAGES }}
          NUGET_HTTP_CACHE_PATH: ${{ env.NUGET_HTTP_CACHE_PATH }}
        run: |
          $ErrorActionPreference = 'Stop'
          $stage = Join-Path $env:RUNNER_TEMP 'uipack-stage'
          $proj  = Join-Path $stage 'project.json'
          if (-not (Test-Path $proj)) { throw "Staged project.json not found at $proj" }
                  
          $stageOut = Join-Path $stage 'output'
          $repoOut  = Join-Path $env:GITHUB_WORKSPACE 'output'
          New-Item -ItemType Directory -Force -Path $stageOut | Out-Null
          New-Item -ItemType Directory -Force -Path $repoOut  | Out-Null

          uipcli package pack "$proj" `
            --output "$stageOut" `
            --outputType '${{ needs.setup.outputs.ptype }}' `
            -v '${{ needs.resolve-dependencies.outputs.version }}' `
            --repositoryUrl 'https://github.com/${{ github.repository }}' `
            --repositoryBranch '${{ github.ref_name }}' `
            --repositoryCommit '${{ github.sha }}' `
            --repositoryType 'git' `
            --projectUrl 'https://project/url.com' `
            --releaseNotes '${{ needs.setup.outputs.notes }}' `
            --libraryOrchestratorUrl '${{ env.BASE_URL }}/' `
            --libraryOrchestratorTenant '${{ env.TENANT }}' `
            -A '${{ env.ORG }}' -I '${{ env.APP_ID }}' -S '${{ env.APP_SECRET }}' `
            --libraryOrchestratorApplicationScope '${{ env.scope }}' `
            --libraryIdentityUrl '${{ env.BASE_URL }}/identity_' `
            --disableBuiltInNugetFeeds `
            --traceLevel 'Verbose' -y 
                    
          Get-ChildItem "$stageOut" -Filter '*.nupkg' | ForEach-Object {
            Copy-Item $_.FullName $repoOut -Force
            Write-Host "Packaged: $($_.Name) -> $repoOut"
          }
            
      - name: Show NuGet cache locations
        shell: powershell
        run: dotnet nuget locals all --list

      - name: Upload artifact
        if: ((${{ needs.setup.outputs.publishable }} == 'true')  && inputs.target_env == 'test') || inputs.target_env == 'dev'
        uses: actions/upload-artifact@v4
        with:
          name: results
          path: ./results/*


      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
              name: output
              path: ./output/

  #    - name: Restore, CI (analyze/test cases), Pack, Upload artifacts
  #      id: CLI
  #      uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/cli@main
  #      with:
  #        full_folder_name:  "${{ fromJSON(needs.setup.outputs.vars).FOLDER_NAME }}"
  #        base_folder_name:  "${{ needs.resolve-dependencies.outputs.base_folder_name }}"
  #        target_env:   ${{ inputs.target_env == 'hotfix' && 'prod' || inputs.target_env }}
  #        version:      ${{ needs.resolve-dependencies.outputs.version }}
  #        ptype:        ${{ needs.setup.outputs.ptype }}
  #        pid:          ${{ needs.setup.outputs.pid }}
  #        base_url:       ${{ env.BASE_URL }}
  #        notes: ${{ needs.setup.outputs.notes }}



  DEPLOY:
    runs-on: ubuntu-latest
    needs: [setup, resolve-dependencies, CLI   ]
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.setup.outputs.deployment_matrix) }}
    concurrency:
      group: deploy-${{ matrix.env }}-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout exact source ref
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.source_ref }}
          persist-credentials: true

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: output
          path: ./output

      - name: auth
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/auth@main
        with:
                target_env: ${{ matrix.env }}
                role_arn: ${{ secrets.RPA_UIPATH_CICD_ROLE_ARN }}
                aws_region: "us-west-2"
                secret_id: ${{ secrets.RPA_UIPATH_CICD_SECRET_ARN }}
                scopes: ${{ env.scope }}


      - name: Deploy
        id: CD
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/cd@main
        with:
          full_folder_name:  "${{ fromJSON(needs.setup.outputs.vars).FOLDER_NAME }}"
          base_folder_name:  "${{ needs.resolve-dependencies.outputs.base_folder_name }}"
          fid:          ${{ needs.resolve-dependencies.outputs.fid }}
          target_env:   ${{ matrix.env }}
          version:      ${{ needs.resolve-dependencies.outputs.version }}
          pid:          ${{ needs.setup.outputs.pid }}
          or_url:       ${{ env.OR_URL }}
          token:        $TOKEN
          entry_point: ${{needs.setup.outputs.entry_point}}



  FORMAT:
    runs-on: ubuntu-latest
    needs: [setup,resolve-dependencies,CLI,DEPLOY]
    outputs:
      final_html:    ${{ steps.compose.outputs.html }}
      final_subject: ${{ steps.compose.outputs.subject }}
      attach_path:   ${{ steps.compose.outputs.attach_path }}
    steps:
      - name: Checkout exact source ref
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.source_ref }}

      - name: Download results artifact
        uses: actions/download-artifact@v4
        with:
          name: results
          path: ./results
        continue-on-error: true

      - name: Ensure email directory
        run: mkdir -p ./email


      - name: Test Results → HTML
        id: test_html
        if: ${{ inputs.target_env == 'test' &&  needs.setup.outputs.publishable == 'true' && hashFiles('results/TestResults.xml') != '' }}
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/test_results@main
        with:
          xml_path: ./results/TestResults.xml
          out_path: ./email/TestResults.html

      # Render analysis only for dev when file exists
      - name: Analysis → HTML
        id: analysis_html
        if: ${{ inputs.target_env == 'dev' && hashFiles('results/analyze.json') != '' }}
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/analysis_results@main
        with:
          json_path: ./results/analyze.json
          out_path:  ./email/analysis-report.html


      - name: Compose final email (table + body + subject)
        id: compose
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/compose_email@main
        with:
          publishable:        ${{ needs.setup.outputs.publishable }}
          target_env:         ${{ inputs.target_env }}
          test_html_path:     ${{ steps.test_html.outputs.html_path }}
          analysis_html_path: ${{ steps.analysis_html.outputs.html_path }}
          source_ref:  ${{ inputs.source_ref }}
          version:     ${{ needs.resolve-dependencies.outputs.version }}
          folder_name: ${{ needs.resolve-dependencies.outputs.base_folder_name }}
          project_id:  ${{ needs.setup.outputs.pid }}
          migrate:     ${{ needs.setup.outputs.migrate }}
          cd_status:   ${{ needs.DEPLOY.result }}


  send:
    needs: [setup,FORMAT]
    runs-on: windows-latest
    steps:
      - name: Send Email (SMTP)
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject:  ${{ needs.format.outputs.final_subject }}
          to:       ${{ needs.setup.outputs.email }}
          from:     "UiPath CI/CD <uipath-cicd@noreply.com>"
          html_body: ${{ needs.format.outputs.final_html }}
          convert_markdown: false
          attachments: ${{ needs.format.outputs.attach_path }}
