name: "Generate queue report"

on:
    workflow_dispatch:
        inputs:
            start:
                description: "Start Date"
                required: true
            end:
                description: "End Date"
                required: true

env:
  scope: "OR.Assets OR.BackgroundTasks OR.Execution OR.Folders OR.Machines OR.Robots OR.Settings OR.TestSets OR.TestSetExecutions OR.TestSetSchedules OR.Users"

permissions:
    write-all

jobs:
  parse-dates:
    runs-on: ubuntu-latest
    outputs:
      start_iso: ${{ steps.parse.outputs.start_iso }}
      end_iso: ${{ steps.parse.outputs.end_iso }}
    steps:
      - name: Parse start/end into UTC ISO (Z)
        id: parse
        shell: bash
        env:
          START_IN: ${{ github.event.inputs.start }}
          END_IN: ${{ github.event.inputs.end }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import os
          from datetime import datetime, timezone
          def parse_mdy(s: str) -> datetime:
            s = s.strip()
            for fmt in ("%m/%d/%Y", "%m/%d/%y"):
              try:
                return datetime.strptime(s, fmt)
              except ValueError:
                pass
            raise SystemExit(f"Unsupported date format: {s} (use MM/DD/YY or MM/DD/YYYY)")
          start = parse_mdy(os.environ["START_IN"]).replace(tzinfo=timezone.utc)
          end   = parse_mdy(os.environ["END_IN"]).replace(tzinfo=timezone.utc)   # end is exclusive
          si = start.strftime("%Y-%m-%dT%H:%M:%SZ")
          ei = end.strftime("%Y-%m-%dT%H:%M:%SZ")
          # print for logs
          print(f"start_iso={si}")
          print(f"end_iso={ei}")
          # set step outputs
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            f.write(f"start_iso={si}\nend_iso={ei}\n")
          PY

      - name: Show parsed ISO values
        shell: bash
        run: |
          echo "start_iso=${{ steps.parse.outputs.start_iso }}"
          echo "end_iso=${{ steps.parse.outputs.end_iso }}"

  scavenge:
    runs-on: windows-latest
    needs: parse-dates
    env:
      START_ISO: ${{ needs.parse-dates.outputs.start_iso }}
      END_ISO: ${{ needs.parse-dates.outputs.end_iso }}
    steps:

      - name: auth
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/auth@main
        with:
                target_env: "dev"
                role_arn: ${{ secrets.RPA_UIPATH_CICD_ROLE_ARN }}
                aws_region: "us-west-2"
                secret_id: ${{ secrets.RPA_UIPATH_CICD_SECRET_ARN }}
                scopes: ${{ env.scope }}

      - name: Scavenge Folder
        shell: bash   # needed for process substitution and $'\t'
        run: |
          set -Eeuo pipefail
          mkdir -p out

          echo "Window (UTC, end exclusive):"
          echo "  START: $START_ISO"
          echo "  END:   $END_ISO"

          echo "::group::Fetch Folders"
          FOLDERS="$(curl --silent --show-error --fail --location \
            --header "Authorization: Bearer $TOKEN" \
            "${{ env.OR_URL }}/odata/Folders?\$select=Id,FullyQualifiedName")"
          echo "$FOLDERS"
          echo "::endgroup::"

          OUT_CSV="out/queue_counts.csv"
          printf 'Folder,Queue Name,Business Exceptions,Application Exceptions,Successful,Total\n' > "$OUT_CSV"

          # iterate folders (your exact loop style)
          while IFS=$'\t' read -r fid fname || [ -n "$fid" ]; do
            fid=${fid%$'\r'}
            fname=${fname%$'\r'}
            [ -n "$fid" ] || continue
            echo "Checking folder: $fname ($fid)"

            echo "::group::Fetch Queues [$fname]"
            QUEUES="$(curl --silent --show-error --location \
              --header "Authorization: Bearer $TOKEN" \
              --header "X-UIPATH-FolderPath: $fname" \
              "${{ env.OR_URL }}/odata/QueueDefinitions?\$select=Id,Name")"
            echo "$QUEUES"
            echo "::endgroup::"

            while IFS=$'\t' read -r qid qname || [ -n "$qid" ]; do
              qid=${qid%$'\r'}
              qname=${qname%$'\r'}
              [ -n "$qid" ] || continue
              echo "  Queue: $qname ($qid)"


              APP_EXCEPTIONS=$(curl --silent --show-error  --location \
                --header "Authorization: Bearer $TOKEN" \
                --header "X-UIPATH-FolderPath: $fname" \
                "${{ env.OR_URL }}/odata/QueueItems/\$count?\$filter=Name eq '${qname}' and EndProcessing ge '${{ env.START_ISO }}' and EndProcessing lt '${{ env.END_ISO }}' and ProcessingExceptionType eq 'ApplicationException'")

              BIZ_EXCEPTIONS=$(curl --silent --show-error  --location \
                --header "Authorization: Bearer $TOKEN" \
                --header "X-UIPATH-FolderPath: $fname" \
                "${{ env.OR_URL }}/odata/QueueItems/\$count?\$filter=Name eq '${qname}' and EndProcessing ge '${{ env.START_ISO }}' and EndProcessing lt '${{ env.END_ISO }}' and ProcessingExceptionType eq 'BusinessException'")

              SUCCESSFUL=$(curl --silent --show-error  --location \
                --header "Authorization: Bearer $TOKEN" \
                --header "X-UIPATH-FolderPath: $fname" \
                "${{ env.OR_URL }}/odata/QueueItems/\$count?\$filter=Name eq '${qname}' and EndProcessing ge '${{ env.START_ISO }}' and EndProcessing lt '${{ env.END_ISO }}' and Status eq 'Successful'")

              TOTAL=$(curl --silent --show-error  --location \
                --header "Authorization: Bearer $TOKEN" \
                --header "X-UIPATH-FolderPath: $fname" \
                "${{ env.OR_URL }}/odata/QueueItems/\$count?\$filter=Name eq '${qname}' and EndProcessing ge '${{ env.START_ISO }}' and EndProcessing lt '${{ env.END_ISO }}'")


              fname_csv=$(printf '%s' "$fname" | sed 's/\"/\"\"/g')
              qname_csv=$(printf '%s' "$qname" | sed 's/\"/\"\"/g')

              printf '"%s","%s",%s,%s,%s,%s\n' \
                "$fname_csv" "$qname_csv" "$BIZ_EXCEPTIONS" "$APP_EXCEPTIONS" "$SUCCESSFUL" "$TOTAL" >> "$OUT_CSV"

            done < <(
              printf '%s' "$QUEUES" \
              | jq -r '.value[] | [(.Id|tostring), (.Name // "")] | @tsv' \
              | tr -d '\r'
            )

          done < <(
            printf '%s' "$FOLDERS" \
            | jq -r '.value[] | [(.Id|tostring), (.FullyQualifiedName // "")] | @tsv' \
            | tr -d '\r'
          )

      - name: Upload raw results
        uses: actions/upload-artifact@v4
        with:
          name: queue-counts
          path: out/queue_counts.csv



  to-xlsx:
    runs-on: ubuntu-latest
    needs: scavenge
    steps:
      - name: Download raw results
        uses: actions/download-artifact@v4
        with:
          name: queue-counts
          path: raw

      - name: Convert CSV â†’ XLSX
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - run: |
          python -m pip install --quiet --upgrade pip
          pip install --quiet pandas openpyxl
          python - <<'PY'
          import pandas as pd
          df = pd.read_csv("raw/queue_counts.csv")
          out = "uipath_queues_summary.xlsx"
          with pd.ExcelWriter(out, engine="openpyxl") as w:
            df.to_excel(w, index=False, sheet_name="Summary")
          print("Wrote", out)
          PY

      - name: Upload XLSX
        uses: actions/upload-artifact@v4
        with:
          name: queue-counts-xlsx
          path: uipath_queues_summary.xlsx
