name: "Generate queue report"

on:
    workflow_dispatch:
        inputs:
            start:
                description: "Start Date"
                required: true
            end:
                description: "End Date"
                required: true

env:
  scope: "OR.Assets OR.BackgroundTasks OR.Execution OR.Folders OR.Machines OR.Robots OR.Settings OR.TestSets OR.TestSetExecutions OR.TestSetSchedules OR.Users"

permissions:
    write-all

jobs:
  parse-dates:
    runs-on: ubuntu-latest
    outputs:
      start_iso: ${{ steps.parse.outputs.start_iso }}
      end_iso: ${{ steps.parse.outputs.end_iso }}
    steps:
      - name: Parse start/end into UTC ISO (Z)
        id: parse
        shell: bash
        env:
          START_IN: ${{ github.event.inputs.start }}
          END_IN: ${{ github.event.inputs.end }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import os
          from datetime import datetime, timezone
          def parse_mdy(s: str) -> datetime:
            s = s.strip()
            for fmt in ("%m/%d/%Y", "%m/%d/%y"):
              try:
                return datetime.strptime(s, fmt)
              except ValueError:
                pass
            raise SystemExit(f"Unsupported date format: {s} (use MM/DD/YY or MM/DD/YYYY)")
          start = parse_mdy(os.environ["START_IN"]).replace(tzinfo=timezone.utc)
          end   = parse_mdy(os.environ["END_IN"]).replace(tzinfo=timezone.utc)   # end is exclusive
          si = start.strftime("%Y-%m-%dT%H:%M:%SZ")
          ei = end.strftime("%Y-%m-%dT%H:%M:%SZ")
          # print for logs
          print(f"start_iso={si}")
          print(f"end_iso={ei}")
          # set step outputs
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            f.write(f"start_iso={si}\nend_iso={ei}\n")
          PY

      - name: Show parsed ISO values
        shell: bash
        run: |
          echo "start_iso=${{ steps.parse.outputs.start_iso }}"
          echo "end_iso=${{ steps.parse.outputs.end_iso }}"

  scavenge:
    runs-on: windows-latest
    needs: parse-dates
    env:
      START_ISO: ${{ needs.parse-dates.outputs.start_iso }}
      END_ISO: ${{ needs.parse-dates.outputs.end_iso }}
    steps:

      - name: auth
        uses: dhillon-shawn/Local-Uipath-CICD/.github/actions/auth@main
        with:
                target_env: "dev"
                role_arn: ${{ secrets.RPA_UIPATH_CICD_ROLE_ARN }}
                aws_region: "us-west-2"
                secret_id: ${{ secrets.RPA_UIPATH_CICD_SECRET_ARN }}
                scopes: ${{ env.scope }}

      - name: Scavenge Folder
        run: |
            set -Eeuo pipefail
            mkdir -p out

            echo "::group::Fetch Folders"
            FOLDERS="$(curl --silent --show-error --fail --location \
              --header "Authorization: Bearer $TOKEN" \
              "${{ env.OR_URL }}/odata/Folders?\$select=Id,FullyQualifiedName")"
            echo "$FOLDERS"
            echo "::endgroup::"

            OUT_CSV="out/queue_counts.csv"
            printf 'Folder,Queue Name,Business Exceptions,Application Exceptions,Successful,Total\n' > "$OUT_CSV"

            csvq() { printf '%s' "$1" | sed 's/"/""/g'; }

            # iterate folders with your exact loop style
            while IFS=$'\t' read -r fid fname || [ -n "$fid" ]; do
              fid=${fid%$'\r'}
              fname=${fname%$'\r'}
              [ -n "$fid" ] || continue
              echo "Checking folder: $fname ($fid)"

              echo "::group::Fetch Queues [$fname]"
              QUEUES="$(curl --silent --show-error --fail --location \
                --header "Authorization: Bearer $TOKEN" \
                --header "X-UIPATH-FolderPath: $fname" \
                 "${{ env.OR_URL }}/odata/QueueDefinitions?\$select=Id,Name")"
              echo "$QUEUES"
              echo "::endgroup::"

              # iterate queues with your loop style
              while IFS=$'\t' read -r qid qname || [ -n "$qid" ]; do
                qid=${qid%$'\r'}
                qname=${qname%$'\r'}
                [ -n "$qid" ] || continue
                echo "  Queue: $qname ($qid)"

                # OData: single-quote the queue name; double embedded single quotes
                qname_odata=${qname//\'/\'\'}   # OData escaping for single quotes

                # Your exact inline calls, with \$count and \$filter escaped so bash doesn't expand them.
                # Also quote the OData string literals.
                APP_EXCEPTIONS=$(curl --silent --show-error --fail --location \
                  --header "Authorization: Bearer $TOKEN" \
                  --header "X-UIPATH-FolderPath: $fname" \
                  "${{ env.OR_URL }}/odata/QueueItems/\$count?\$filter=Name eq '${qname_odata}' and EndProcessing ge '${START_ISO}' and EndProcessing lt '${END_ISO}' and ProcessingExceptionType eq 'ApplicationException'")

                BIZ_EXCEPTIONS=$(curl --silent --show-error --fail --location \
                  --header "Authorization: Bearer $TOKEN" \
                  --header "X-UIPATH-FolderPath: $fname" \
                  "${{ env.OR_URL }}/odata/QueueItems/\$count?\$filter=Name eq '${qname_odata}' and EndProcessing ge '${START_ISO}' and EndProcessing lt '${END_ISO}' and ProcessingExceptionType eq 'BusinessException'")

                SUCCESSFUL=$(curl --silent --show-error --fail --location \
                  --header "Authorization: Bearer $TOKEN" \
                  --header "X-UIPATH-FolderPath: $fname" \
                  "${{ env.OR_URL }}/odata/QueueItems/\$count?\$filter=Name eq '${qname_odata}' and EndProcessing ge '${START_ISO}' and EndProcessing lt '${END_ISO}' and Status eq 'Successful'")

                TOTAL=$(curl --silent --show-error --fail --location \
                  --header "Authorization: Bearer $TOKEN" \
                  --header "X-UIPATH-FolderPath: $fname" \
                  "${{ env.OR_URL }}/odata/QueueItems/\$count?\$filter=Name eq '${qname_odata}' and EndProcessing ge '${START_ISO}' and EndProcessing lt '${END_ISO}'")

                printf '"%s","%s",%s,%s,%s,%s\n' \
                  "$(csvq "$fname")" "$(csvq "$qname")" "$BIZ_EXCEPTIONS" "$APP_EXCEPTIONS" "$SUCCESSFUL" "$TOTAL" >> "$OUT_CSV"

              done < <(
                printf '%s' "$QUEUES" \
                | jq -r '.value[] | [(.Id|tostring), (.Name // "")] | @tsv' \
                | tr -d '\r'
              )

            done < <(
              printf '%s' "$FOLDERS" \
              | jq -r '.value[] | [(.Id|tostring), (.FullyQualifiedName // "")] | @tsv' \
              | tr -d '\r'
            )
              
      - name: Upload raw results
        uses: actions/upload-artifact@v4
        with:
          name: queue-counts
          path: out/*



  to-xlsx:
    runs-on: ubuntu-latest
    needs: scavenge
    steps:
      - name: Download raw results
        uses: actions/download-artifact@v4
        with:
          name: queue-counts
          path: raw

      - name: Convert CSV â†’ XLSX
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - run: |
          python -m pip install --quiet --upgrade pip
          pip install --quiet pandas openpyxl
          python - <<'PY'
          import pandas as pd
          df = pd.read_csv("raw/queue_counts.csv")
          out = "uipath_queues_summary.xlsx"
          with pd.ExcelWriter(out, engine="openpyxl") as w:
            df.to_excel(w, index=False, sheet_name="Summary")
          print("Wrote", out)
          PY

      - name: Upload XLSX
        uses: actions/upload-artifact@v4
        with:
          name: queue-counts-xlsx
          path: uipath_queues_summary.xlsx
