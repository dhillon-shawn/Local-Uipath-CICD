# .github/actions/aws-env-pair/action.yml
name: "AWS env pair -> APP_ID/APP_SECRET"
description: "Assume role, fetch one JSON secret, map {ENV}_APP_ID/_APP_SECRET -> APP_ID/APP_SECRET"
inputs:
  env:
    description: "Environment (e.g. DEV|STAGE|PROD)"
    required: true
  role_arn:
    description: "AWS role to assume (OIDC)"
    required: true
  aws_region:
    description: "AWS region"
    required: true
  secret_id:
    description: "Secret name/ARN containing keys like DEV_APP_ID/DEV_APP_SECRET"
    required: true
runs:
  using: "composite"
  steps:
    - name: Configure AWS (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.role_arn }}
        aws-region: ${{ inputs.aws_region }}

    # Keep the JSON as a single env var named UIPATH
    - name: Get secret as JSON string
      uses: aws-actions/aws-secretsmanager-get-secrets@v2
      with:
        secret-ids: |
          UIPATH,${{ inputs.secret_id }}
        parse-json-secrets: false

    # Cross-OS parse & export (no bash/powershell scripts)
    - name: Map {ENV}_APP_ID/_APP_SECRET -> APP_ID/APP_SECRET
      uses: actions/github-script@v7
      env:
        TARGET_ENV: ${{ inputs.env }}
        SECRET_NAME: ${{ inputs.secret_id }}
        # UIPATH env var is provided by the previous step
      with:
        script: |
          const envName = (process.env.TARGET_ENV || '').trim();
          if (!envName) { core.setFailed('inputs.env is required'); return; }

          const upper = envName.toUpperCase();
          const raw = process.env.UIPATH;
          if (!raw) { core.setFailed('UIPATH env var is empty (check the alias in aws-secretsmanager-get-secrets).'); return; }

          let obj;
          try { obj = JSON.parse(raw); }
          catch { core.setFailed('SecretString is not valid JSON'); return; }

          // Case-insensitive: normalize keys to UPPERCASE
          const map = {};
          for (const [k,v] of Object.entries(obj)) map[k.toUpperCase()] = v;

          const idKey = `${upper}_APP_ID`;
          const secretKey = `${upper}_APP_SECRET`;
          const appId = map[idKey];
          const appSecret = map[secretKey];

          if (!appId || !appSecret) {
            const pref = `${upper}_`;
            const candidates = Object.keys(map).filter(k => k.startsWith(pref)).join(', ');
            core.info(`Found keys with prefix '${pref}': ${candidates || '(none)'}`);
            core.setFailed(`Missing keys '${idKey}' or '${secretKey}' in secret '${process.env.SECRET_NAME}'.`);
            return;
          }

          core.setSecret(String(appId));
          core.setSecret(String(appSecret));
          core.exportVariable('APP_ID', String(appId));
          core.exportVariable('APP_SECRET', String(appSecret));
