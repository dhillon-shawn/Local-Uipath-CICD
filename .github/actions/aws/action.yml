name: "AWS env pair â†’ APP_ID/APP_SECRET/FULL_URL (+ token)"
description: "Assume role, fetch one JSON secret, map {ENV}_*, build FULL_URL, fetch token at BASE_URL/identity"
inputs:
  env:
    description: "Environment (e.g. DEV|STAGE|PROD)"
    required: true
  role_arn:
    description: "AWS role to assume (OIDC)"
    required: true
  aws_region:
    description: "AWS region"
    required: true
  secret_id:
    description: "Secret name/ARN containing {ENV}_APP_ID/_APP_SECRET/_BASE_URL/_ORG/_TENANT"
    required: true
outputs:
  token:
    description: "Access token"
    value: ${{ steps.token.outputs.token }}
runs:
  using: "composite"
  steps:
    - name: Configure AWS
      if: ${{ !env.UIPATH }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.role_arn }}
        aws-region: ${{ inputs.aws_region }}

    - name: Get secret JSON as env (UIPATH)
      if: ${{ !env.UIPATH }}
      uses: aws-actions/aws-secretsmanager-get-secrets@v2
      with:
        secret-ids: |
          UIPATH,${{ inputs.secret_id }}
        parse-json-secrets: false

    - name: Map vars and fetch token
      id: token
      uses: actions/github-script@v7
      env:
        TARGET_ENV: ${{ inputs.env }}
        ACTIONS_STEP_DEBUG: "true"
        SCOPE: "OR.Assets OR.BackgroundTasks  OR.Execution  OR.Folders  OR.Jobs  OR.License OR.Machines OR.Queues OR.Robots  OR.Settings OR.TestDataQueues OR.TestSetExecutions OR.TestSets OR.TestSetSchedules OR.Users"
      with:
        script: |
          try {
            const ENV = (process.env.TARGET_ENV || '').toUpperCase();
            const PARSE = JSON.parse(process.env.UIPATH); 

            const APP_ID     = String(PARSE[`${ENV}_APP_ID`]);
            const APP_SECRET = String(PARSE[`${ENV}_APP_SECRET`]);
            const BASE_URL   = String(PARSE[`${ENV}_BASE_URL`]);
            const ORG        = String(PARSE[`${ENV}_ORG`]);
            const TENANT     = String(PARSE[`${ENV}_TENANT`]);

            core.setSecret(APP_ID);
            core.setSecret(APP_SECRET);
            core.exportVariable('APP_ID', APP_ID);
            core.exportVariable('APP_SECRET', APP_SECRET);
            core.exportVariable('BASE_URL', BASE_URL);

            const OR_URL = `${BASE_URL}/${ORG}/${TENANT}/orchestrator_`;
            core.exportVariable('OR_URL', OR_URL);

            const tokenUrl = `${BASE_URL.replace(/\/+$/,'')}/identity_/connect/token`;
            core.debug(`Token URL: ${tokenUrl}`);
            core.debug(`Scope: ${process.env.SCOPE}`);

            const params = new URLSearchParams();
            params.set('grant_type', 'client_credentials');
            params.set('client_id', APP_ID);
            params.set('client_secret', APP_SECRET);
            if (process.env.SCOPE) params.set('scope', process.env.SCOPE);

            const res = await fetch(tokenUrl, {
              method: 'POST',
              headers: { 'content-type':'application/x-www-form-urlencoded', 'accept':'application/json' },
              body: params.toString()
            });

            const statusLine = `HTTP ${res.status} ${res.statusText}`;
            const ct = res.headers.get('content-type') || '';
            const bodyText = await res.text();

            core.info(`Auth response status: ${statusLine}`);
            core.info(`Content-Type: ${ct}`);

            let data;
            try { data = JSON.parse(bodyText); } catch { data = { raw: bodyText }; }

            core.info(`Auth response body: ${JSON.stringify(data, null, 2)}`);

            // Fail on non-2xx
            if (!res.ok) {
              core.setFailed(`Token request failed: ${statusLine}`);
              return;
            }

            // Require a token
            const token = (data && (data.access_token || data.token)) ? String(data.access_token || data.token) : '';
            if (!token) {
              core.setFailed('Token missing in successful response');
              return;
            }

            core.setSecret(token);
            core.exportVariable('TOKEN', token);
            core.setOutput('token', token);
          } catch (err) {
            core.setFailed(`Token step threw: ${err && err.message ? err.message : String(err)}`);
          }
