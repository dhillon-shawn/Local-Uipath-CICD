name: "SET AWS Credentials"
description: "Assume role, fetch one JSON secret, map"
inputs:
  env:
    description: "Environment"
    required: true
  role_arn:
    description: "AWS role"
    required: true
  aws_region:
    description: "AWS region"
    default: "us-west-2"
    required: true
  secret_id:
    description: "Secret name/ARN containing keys like DEV_APP_ID/DEV_APP_SECRET"
    required: true
runs:
  using: "composite"
  steps:
    - name: Configure AWS (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.role_arn }}
        aws-region: ${{ inputs.aws_region }}

    # Keep the JSON as a single env var named UIPATH
    - name: Get secret as JSON string
      uses: aws-actions/aws-secretsmanager-get-secrets@v2
      with:
        secret-ids: |
          UIPATH,${{ inputs.secret_id }}
        parse-json-secrets: false

    - name: Map {ENV}_* -> APP_ID/APP_SECRET/BASE_URL/OR_URL
      uses: actions/github-script@v7
      env:
        TARGET_ENV: ${{ inputs.env }}
        SECRET_NAME: ${{ inputs.secret_id }}
        # UIPATH is set by the previous secrets step
      with:
        script: |
          const envName = (process.env.TARGET_ENV || '').trim();
          if (!envName) { core.setFailed('inputs.env is required'); return; }

          const upper = envName.toUpperCase();
          const raw = process.env.UIPATH;
          if (!raw) { core.setFailed('UIPATH env var is empty (check the alias in aws-secretsmanager-get-secrets).'); return; }

          let obj;
          try { obj = JSON.parse(raw); }
          catch { core.setFailed('SecretString is not valid JSON'); return; }

          // Case-insensitive: normalize keys to UPPERCASE
          const map = {};
          for (const [k,v] of Object.entries(obj)) map[k.toUpperCase()] = v;

          const need = [
            `${upper}_APP_ID`,
            `${upper}_APP_SECRET`,
            `${upper}_BASE_URL`,
            `${upper}_ORG`,
            `${upper}_TENANT`,
          ];

          const missing = need.filter(k => !(k in map) || map[k] === undefined || map[k] === null || String(map[k]).length === 0);
          if (missing.length) {
            core.setFailed(`Missing required keys in secret`);
            return;
          }

          const appId = String(map[`${upper}_APP_ID`]);
          const appSecret = String(map[`${upper}_APP_SECRET`]);
          let base = String(map[`${upper}_BASE_URL`]);
          let org = String(map[`${upper}_ORG`]);
          let tenant = String(map[`${upper}_TENANT`]);

          // Mask secrets
          core.setSecret(appId);
          core.setSecret(appSecret);

          const full = `${base}/${encodeURIComponent(org)}/${encodeURIComponent(tenant)}/orchestrator_`;

          // Export
          core.exportVariable('APP_ID', appId);
          core.exportVariable('APP_SECRET', appSecret);
          core.exportVariable('BASE_URL', base);
          core.exportVariable('OR_URL', full);


    - name: Fetch OAuth2 token (client_credentials)
      id: get_token
      uses: actions/github-script@v7
      env:
        SCOPE: "OR.Assets OR.BackgroundTasks  OR.Execution  OR.Folders  OR.Jobs  OR.License OR.Machines OR.Queues OR.Robots  OR.Settings OR.TestDataQueues OR.TestSetExecutions OR.TestSets OR.TestSetSchedules OR.Users"
      with:
        script: |
          // Build token URL from BASE_URL + TOKEN_PATH (default 'identity')
          const base = (process.env.BASE_URL || '').trim();
          if (!base) { core.setFailed('BASE_URL is not set'); return; }
          const path = String( '/identity_/connect/token').replace(/^\/+/, '');
          const url  = `${base.replace(/\/+$/,'')}/${path}`;

          // Prepare client credentials payload
          const params = new URLSearchParams();
          params.set('grant_type','client_credentials');
          params.set('client_id', process.env.APP_ID || '');
          params.set('client_secret', process.env.APP_SECRET || '');
          if (process.env.SCOPE)    params.set('scope', process.env.SCOPE);

          const res = await fetch(url, {
            method: 'POST',
            headers: { 'content-type':'application/x-www-form-urlencoded', 'accept': 'application/json' },
            body: params.toString()
          });

          const bodyText = await res.text();
          let data;
          try { data = JSON.parse(bodyText) } catch { core.setFailed(`Token endpoint (${url}) did not return JSON. HTTP ${res.status}`); return; }
          if (!res.ok) { core.setFailed(`Token request failed (HTTP ${res.status}): ${data.error || bodyText}`); return; }

          const token = data.access_token || data.token || '';
          if (!token) { core.setFailed('No access_token in response'); return; }

          core.setSecret(token);
          core.exportVariable('ACCESS_TOKEN', token);
          core.exportVariable('TOKEN_URL', url);
          core.setOutput('token', token);
          core.setOutput('token_url', url);
          if (data.expires_in) core.exportVariable('ACCESS_TOKEN_EXPIRES_IN', String(data.expires_in));
