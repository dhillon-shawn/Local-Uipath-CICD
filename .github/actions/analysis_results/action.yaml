name: "Format UiPath analyze.json to HTML"
description: "Reads analyze.json (utf-8/utf-16) and renders a clean HTML report"

inputs:
  json_path: { required: true, description: "Path to analyze.json" }
  out_path:  { required: false, default: "./email/analysis-report.html", description: "Path to HTML results" }

outputs:
  html:
    value: ${{ steps.analysis_report.outputs.html }}
    description: "HTML body"
  html_path:
    value: ${{ steps.analysis_report.outputs.html_path }}
    description: "Path to HTML file"

runs:
  using: "composite"
  steps:
    - name: Ensure output dir
      shell: bash
      run: mkdir -p "$(dirname "${{ inputs.out_path }}")"

    - name: Convert JSON to HTML (readable)
      id: analysis_report
      uses: actions/github-script@v7
      env:
        IN:  ${{ inputs.json_path }}
        OUT: ${{ inputs.out_path }}
      with:
        script: |
          /**
           * Human-friendly converter:
           * - Reads JSON (UTF-8/UTF-16 with BOM)
           * - Escapes HTML
           * - Preserves [text](url) links
           * - Renders a simple report
           * Expected JSON: array of [workflow, description, recommendation]
           */
          const fs = require('node:fs');
          const path = require('node:path');
          const {TextDecoder} = require('node:util');

          // -------- Helpers --------

          /** Decode a buffer that may be UTF-8/UTF-16LE/UTF-16BE with optional BOM */
          function decodeWithBom(buf) {
            const hasUtf8BOM = buf.length >= 3 && buf[0] === 0xEF && buf[1] === 0xBB && buf[2] === 0xBF;
            if (hasUtf8BOM) return buf.slice(3).toString('utf8');

            const hasLEBOM = buf.length >= 2 && buf[0] === 0xFF && buf[1] === 0xFE;
            if (hasLEBOM) return buf.slice(2).toString('utf16le');

            const hasBEBOM = buf.length >= 2 && buf[0] === 0xFE && buf[1] === 0xFF;
            if (hasBEBOM) return new TextDecoder('utf-16be').decode(buf.slice(2));

            // No BOM: try UTF-8, then UTF-16LE as a fallback
            try { return buf.toString('utf8'); } catch { return buf.toString('utf16le'); }
          }

          /** Minimal, safe HTML escape for text/attrs */
          function escapeHtml(s) {
            return String(s).replace(/[&<>"']/g, ch => (
              ch === '&' ? '&amp;' :
              ch === '<' ? '&lt;'  :
              ch === '>' ? '&gt;'  :
              ch === '"' ? '&quot;': '&#39;'
            ));
          }

          /** Escape everything, but turn [text](url) spans into links */
          function linkifyMarkdown(text) {
            const input = String(text);
            const re = /\[([^\]]+)\]\(([^)]+)\)/g;
            let out = '', last = 0, m;

            while ((m = re.exec(input)) !== null) {
              out += escapeHtml(input.slice(last, m.index));
              const linkText = escapeHtml(m[1]);
              const url = escapeHtml(m[2]);
              out += `<a href="${url}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
              last = re.lastIndex;
            }
            out += escapeHtml(input.slice(last));
            return out;
          }

          /** Ensure data is an array of 3-item arrays */
          function validateData(arr) {
            if (!Array.isArray(arr)) throw new Error('analyze.json must be an array');
            for (const [i, item] of arr.entries()) {
              if (!Array.isArray(item) || item.length < 3) {
                throw new Error(`Invalid item at index ${i}. Expected [workflow, description, recommendation].`);
              }
            }
          }

          /** Render one issue block */
          function renderIssue([workflow, description, recommendation]) {
            const name = workflow || 'Project Configuration';
            const klass = workflow ? 'workflow' : 'project';
            return `
              <div class="issue">
                <div class="${klass}">${escapeHtml(name)}</div>
                <div class="description">${escapeHtml(description)}</div>
                <div class="recommendation"><strong>Recommendation:</strong> ${linkifyMarkdown(recommendation)}</div>
              </div>`;
          }

          /** Render full HTML document */
          function renderDocument(data) {
            const css = `
              body{font-family:Arial,Helvetica,sans-serif;margin:40px;background:#f5f5f5}
              .container{max-width:900px;margin:0 auto;background:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1)}
              h1{color:#2c3e50;text-align:center}
              .issue{border-bottom:1px solid #eee;padding:16px 0}
              .workflow{font-weight:700;color:#e74c3c}
              .project{font-weight:700;color:#f39c12}
              .description{margin:10px 0;color:#555}
              .recommendation{background:#f8f9fa;padding:12px;border-left:3px solid #28a745;margin-top:10px}
              a{color:#3498db}
            `;

            return `<!DOCTYPE html>
            <html>
              <head>
                <meta charset="utf-8">
                <title>UiPath Analysis Report</title>
                <style>${css}</style>
              </head>
              <body>
                <div class="container">
                  <h1>UiPath Analysis Report</h1>
                  <p><strong>${data.length} issues found</strong></p>
                  ${data.map(renderIssue).join('\n')}
                </div>
              </body>
            </html>`;
          }

          // -------- Main --------
          const IN = process.env.IN;
          const OUT = process.env.OUT;

          // Ensure output directory exists (useful if caller overrides out_path)
          fs.mkdirSync(path.dirname(OUT), {recursive: true});

          // Load + parse JSON
          const buffer = fs.readFileSync(IN);
          const jsonText = decodeWithBom(buffer);
          const data = JSON.parse(jsonText);
          validateData(data);

          // Build, write, and expose outputs
          const html = renderDocument(data);
          fs.writeFileSync(OUT, html, 'utf8');

          core.setOutput('html', html);
          core.setOutput('html_path', OUT);
