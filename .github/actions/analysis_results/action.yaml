name: "Format UiPath analyze.json to HTML"
description: "Reads analyze.json (utf-8/utf-16) and renders a clean HTML report"

inputs:
  json_path: { required: true, description: "Path to analyze.json" }
  out_path:  { required: false, default: "./email/analysis-report.html", description: "Path to HTML results" }

outputs:
  html:
    value: ${{ steps.analysis_report.outputs.html }}
    description: "HTML body"
  html_path:
    value: ${{ steps.analysis_report.outputs.html_path }}
    description: "Path to HTML file"

runs:
  using: "composite"
  steps:
    - name: Ensure output dir
      shell: bash
      run: mkdir -p "$(dirname "${{ inputs.out_path }}")"

    - name: Analysis → HTML (simple, correct Learn more links)
      id: analysis_html
      uses: actions/github-script@v7
      env:
        IN:  ${{ inputs.json_path }}          # e.g. ./results/analyze.json
        OUT: ${{ inputs.out_path }}           # e.g. ./email/analysis-report.html
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const inPath  = process.env.IN || '';
          const outPath = process.env.OUT || 'email/analysis-report.html';
          if (!inPath) { core.setFailed('IN was empty.'); return; }
          if (!fs.existsSync(inPath)) { core.setFailed(`IN not found: ${inPath}`); return; }

          // ---------- helpers ----------
          const esc = s => String(s ?? '')
            .replace(/&/g,'&amp;').replace(/</g,'&lt;')
            .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
            .replace(/'/g,'&#39;');

          // Turn [label](url) into tokens we restore after escaping
          function tokenizeMarkdownLinks(src) {
            const anchors = [];
            const text = String(src || '').replace(/\[([^\]]+)\]\(\s*(https?:\/\/[^\s)]+)\s*\)/gi,
              (_m, label, url) => {
                const id = anchors.push({ label, url }) - 1;
                return `__A${id}__`;
              }
            );
            return { text, anchors };
          }

          // Render text with:
          //  - existing markdown links preserved
          //  - "Learn more" converted to doc link if provided
          //  - raw URLs linked
          //  - no extra "Read more" added
          function renderText(src, docLink) {
            let original = String(src || '');

            // Tokenize markdown links first
            const { text: t0, anchors } = tokenizeMarkdownLinks(original);
            let t = t0;

            // If a DocumentationLink is provided:
            if (docLink) {
              const dl = String(docLink);

              // Remove raw occurrences of the doc URL to avoid showing it in-text
              const escRe = dl.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              t = t.replace(new RegExp(escRe, 'g'), '');

              // Replace any plain "Learn more" text with a link to the doc
              // (case-insensitive, optional period)
              t = t.replace(/(?:^|\s|\()learn\s+more\.?(?=\s|$|\))/gi, (m) => {
                const id = anchors.push({ label: 'Learn more', url: dl }) - 1;
                return m.replace(/learn\s+more\.?/i, `__A${id}__`);
              });
            }

            // Linkify remaining bare URLs (that aren’t already markdown-linked)
            t = t.replace(/\bhttps?:\/\/[^\s<>"')]+/gi, (u) => {
              const id = anchors.push({ label: u, url: u }) - 1;
              return `__A${id}__`;
            });

            // Escape the rest
            let out = esc(t);

            // Basic formatting
            out = out
              .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
              .replace(/`([^`]+)`/g, '<code style="background:#f4f4f5;border:1px solid #e4e4e7;border-radius:4px;padding:1px 4px;">$1</code>')
              .replace(/\r?\n\*\* /g, '<br>&nbsp;&nbsp;• ')
              .replace(/\r?\n\* /g, '<br>• ')
              .replace(/\r?\n/g, '<br>');

            // Restore anchor tokens as <a>
            for (let i = 0; i < anchors.length; i++) {
              const a = anchors[i];
              const html = `<a href="${esc(a.url)}" style="color:#1d4ed8;text-decoration:none;">${esc(a.label)}</a>`;
              out = out.split(`__A${i}__`).join(html);
            }
            return out;
          }

          function normPath(fp) {
            let f = String(fp || '').replace(/\\/g,'/');
            const ws = (process.env.GITHUB_WORKSPACE || '').replace(/\\/g,'/').replace(/\/+$/,'');
            if (ws && f.startsWith(ws + '/')) f = f.slice(ws.length + 1);
            return f || '(project)';
          }

          // ---------- build ----------
          const data = JSON.parse(fs.readFileSync(inPath, 'utf8'));
          const list = Array.isArray(data) ? data : (data.Results || data.results || []);

          const sevMeta = {
            1: { name:'Error',   icon:'❌', bg:'#fde2e2' },
            2: { name:'Warning', icon:'⚠️', bg:'#fff4e5' },
            3: { name:'Info',    icon:'ℹ️', bg:'#e7f3ff' },
          };

          // group by file
          const groups = new Map();
          let totalErr=0,totalWarn=0,totalInfo=0;

          for (const x of list) {
            const row = {
              sev: Number(x.ErrorSeverity ?? 0),
              rule: String(x.RuleName ?? ''),
              desc: x.Description ?? '',
              rec:  x.Recommendation ?? '',
              link: String(x.DocumentationLink ?? ''),
              file: normPath(x.FilePath),
            };
            if (row.sev === 1) totalErr++; else if (row.sev === 2) totalWarn++; else if (row.sev === 3) totalInfo++;
            if (!groups.has(row.file)) groups.set(row.file, []);
            groups.get(row.file).push(row);
          }

        
          const css = {
            card: 'border:1px solid #e5e7eb;border-radius:12px;margin:12px 0;background:#ffffff;',
            head: 'display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid #e5e7eb;background:#f9fafb;',
            file: 'font-family:Consolas,Menlo,Monaco,ui-monospace,monospace;font-weight:600;color:#111827;',
            chips: 'display:flex;gap:8px;',
            chip: (bg,fg)=>`border-radius:999px;padding:4px 10px;font-size:12px;font-weight:600;background:${bg};color:${fg};`,
            wrap: 'overflow:auto;max-width:100%;',
            table: 'border-collapse:separate;border-spacing:0;width:100%;table-layout:fixed;border:1px solid #e5e7eb;',
            th:   'background:#f8fafc;border-bottom:1px solid #e5e7eb;font-weight:700;text-align:left;padding:8px 10px;',
            td:   'border-top:1px solid #e5e7eb;padding:8px 10px;vertical-align:top;word-break:break-word;',
            tdSev: 'white-space:nowrap;width:120px;',
            h1:   'margin:0 0 6px 0;font-size:20px;color:#0f172a;',
            sub:  'margin:0 0 12px 0;color:#475569;',
            totals: 'display:flex;gap:10px;margin:8px 0 16px 0;',
            pill: (bg,fg,bd)=>`border-radius:999px;padding:6px 12px;font-weight:700;border:1px solid ${bd};background:${bg};color:${fg};`,
          };

          const sections = [];
          for (const [fileKey, items] of Array.from(groups.entries()).sort((a,b)=>a[0].localeCompare(b[0]))) {
            items.sort((a,b)=>(a.sev-b.sev)||a.rule.localeCompare(b.rule));
            const c = { err: items.filter(i=>i.sev===1).length, warn: items.filter(i=>i.sev===2).length, info: items.filter(i=>i.sev===3).length };

            let html = `<div style="${css.card}">
            <div style="${css.head}">
              <div style="${css.file}">${esc(fileKey)}</div>
              <div style="${css.chips}">
                <span style="${css.chip('#fecaca','#7f1d1d')}">❌ ${c.err}</span>
                <span style="${css.chip('#fed7aa','#7c2d12')}">⚠️ ${c.warn}</span>
                <span style="${css.chip('#bfdbfe','#1e3a8a')}">ℹ️ ${c.info}</span>
              </div>
            </div>
            <div style="padding:10px;">
              <div style="${css.wrap}">
                <table style="${css.table}">
                  <thead><tr>
                    <th style="${css.th}">Severity</th>
                    <th style="${css.th}">Rule</th>
                    <th style="${css.th}">Description</th>
                    <th style="${css.th}">Recommendation</th>
                  </tr></thead><tbody>`;

            for (const r of items) {
              const sev = sevMeta[r.sev] || { name:'', icon:'', bg:'#fff' };
              html += `<tr style="background:${sev.bg};">
                <td style="${css.td}${css.tdSev}">${sev.icon} ${sev.name}</td>
                <td style="${css.td}">${esc(r.rule)}</td>
                <td style="${css.td}">${renderText(r.desc, r.link)}</td>
                <td style="${css.td}">${renderText(r.rec,  r.link)}</td>
              </tr>`;
            }

            html += `</tbody></table></div></div></div>`;
            sections.push(html);
          }

          const when = new Date().toISOString();
          const outHtml = `<!doctype html><html><body style="font-family:Arial,Helvetica,sans-serif;margin:20px;color:#0f172a;background:#ffffff;">
            <h1 style="${css.h1}">UiPath Analyzer Report</h1>
            <p style="${css.sub}">Generated: ${esc(when)}</p>
            <div style="${css.totals}">
              <span style="${css.pill('#fff1f2','#b91c1c','#fecaca')}">❌ Errors: ${totalErr}</span>
              <span style="${css.pill('#fff7ed','#b45309','#fed7aa')}">⚠️ Warnings: ${totalWarn}</span>
              <span style="${css.pill('#eff6ff','#1d4ed8','#bfdbfe')}">ℹ️ Info: ${totalInfo}</span>
            </div>
            ${sections.join('\n')}
          </body></html>`;

          fs.mkdirSync(path.dirname(outPath), { recursive: true });
          fs.writeFileSync(outPath, outHtml, 'utf8');
          core.setOutput('html_path', outPath);
