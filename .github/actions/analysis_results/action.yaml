name: "Format UiPath analyze.json to HTML"
description: "Reads analyze.json (utf-8/utf-16) and renders a clean HTML report"

inputs:
  json_path: { required: true, description: "Path to analyze.json" }
  out_path:  { required: false, default: "./email/analysis-report.html", description: "Path to HTML results" }

outputs:
  html:
    value: ${{ steps.analysis_report.outputs.html }}
    description: "HTML body"
  html_path:
    value: ${{ steps.analysis_report.outputs.html_path }}
    description: "Path to HTML file"

runs:
  using: "composite"
  steps:
    - name: Ensure output dir
      shell: bash
      run: mkdir -p "$(dirname "${{ inputs.out_path }}")"

    - name: Convert JSON to HTML (readable)
      id: analysis_report
      uses: actions/github-script@v7
      env:
        IN:  ${{ inputs.json_path }}          # file OR directory
        OUT: ${{ inputs.out_path }}           # e.g., artifacts/analyzer-report.html
        SHOW_CODE: "false"                    # show ErrorCode/Link column? set "true" to display
        TRIM_PREFIX: ""                       # optional extra prefix to strip from file paths
      with:
        script: |
          const fs = require('fs/promises');
          const path = require('path');

          const inPath  = process.env.IN || '';
          const outPath = process.env.OUT || 'analyzer-report.html';
          const showCode = /^true$/i.test(process.env.SHOW_CODE || 'false');
          const trimPrefix = (process.env.TRIM_PREFIX || '').replace(/\\/g,'/');

          if (!inPath) { core.setFailed('IN was empty. Set env IN to a JSON file or directory.'); return; }

          async function exists(p){ try{ await fs.access(p); return true; } catch { return false; } }
          async function isDir(p){ try{ return (await fs.stat(p)).isDirectory(); } catch { return false; } }
          async function *walk(dir){
            for (const e of await fs.readdir(dir, { withFileTypes:true })) {
              const f = path.join(dir, e.name);
              if (e.isDirectory()) yield* walk(f);
              else if (e.isFile() && /\.json$/i.test(e.name)) yield f;
            }
          }

          // --- formatting helpers ---
          function escapeHtml(s){
            return String(s ?? '')
              .replace(/&/g,'&amp;').replace(/</g,'&lt;')
              .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
          }
          function mdLite(s, docLink){
            // escape, then apply minimal markdown & linkification; preserve newlines
            let t = escapeHtml(String(s ?? ''));
            // **bold**
            t = t.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            // `code`
            t = t.replace(/`([^`]+)`/g, '<code>$1</code>');
            // URLs
            t = t.replace(/\bhttps?:\/\/[^\s<]+/gi, (u) => `<a href="${u}">${u}</a>`);
            // "Learn more." -> doc link if present
            if (docLink) t = t.replace(/\bLearn more\.?/gi, `<a href="${escapeHtml(docLink)}">Learn more</a>`);
            // preserve line breaks
            t = t.replace(/\r?\n/g,'<br>');
            // collapse stray tabs -> middot
            t = t.replace(/\t+/g, ' · ');
            return t;
          }
          function renderValue(v, docLink){
            if (v == null) return '';
            if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {
              return mdLite(v, docLink);
            }
            if (Array.isArray(v)) {
              const items = v.map(x => `<li>${renderValue(x, docLink)}</li>`).join('');
              return `<ul class="list">${items}</ul>`;
            }
            if (typeof v === 'object') {
              // Try common fields first
              const keysPref = ['Message','Text','Value','Description','Reason','Error','Details'];
              for (const k of keysPref) if (v[k] != null) return renderValue(v[k], docLink);
              // Fallback: key: value list (1 level)
              const items = Object.entries(v).map(([k,val]) =>
                `<li><strong>${escapeHtml(k)}:</strong> ${renderValue(val, docLink)}</li>`).join('');
              return `<ul class="list">${items}</ul>`;
            }
            return mdLite(String(v), docLink);
          }
          function normalizeFilePath(fp){
            let f = String(fp||'').replace(/\\/g,'/');
            const ws = (process.env.GITHUB_WORKSPACE || '').replace(/\\/g,'/').replace(/\/+$/,'');
            if (ws && f.startsWith(ws + '/')) f = f.slice(ws.length + 1);
            if (trimPrefix && f.startsWith(trimPrefix)) f = f.slice(trimPrefix.length);
            return f;
          }
          function toResultsArray(json){
            if (Array.isArray(json)) return json;
            if (json && Array.isArray(json.Results)) return json.Results;
            if (json && Array.isArray(json.results)) return json.results;
            return [];
          }

          const sevMeta = {
            1: { name:'Error',   icon:'❌', class:'sev-error'   },
            2: { name:'Warning', icon:'⚠️', class:'sev-warning' },
            3: { name:'Info',    icon:'ℹ️', class:'sev-info'    },
          };

          function renderTable(rows){
            const columns = [
              {key:'Severity', label:'Severity', render:(r)=>`${sevMeta[r.ErrorSeverity]?.icon || ''} ${sevMeta[r.ErrorSeverity]?.name || ''}`},
              ...(showCode ? [{
                key:'ErrorCode', label:'ErrorCode / Link',
                render:(r)=> r.DocumentationLink
                  ? `<a href="${escapeHtml(r.DocumentationLink)}">${escapeHtml(r.ErrorCode)}</a>`
                  : escapeHtml(r.ErrorCode)
              }] : []),
              {key:'RuleName', label:'Rule', render:(r)=> escapeHtml(r.RuleName)},
              {key:'Description', label:'Description', class:'wrap', render:(r)=> renderValue(r.Description, r.DocumentationLink)},
              {key:'Recommendation', label:'Recommendation', class:'wrap', render:(r)=> renderValue(r.Recommendation, r.DocumentationLink)},
              {key:'FilePath', label:'File Path', class:'path', render:(r)=> escapeHtml(normalizeFilePath(r.FilePath))},
            ];

            const thead = `<thead><tr>${columns.map(c=>`<th>${c.label}</th>`).join('')}</tr></thead>`;
            const tbody = rows.map(r=>{
              const sev = sevMeta[r.ErrorSeverity] || {};
              const tds = columns.map(c=>`<td class="${c.class||''}">${c.render(r)}</td>`).join('');
              return `<tr class="${sev.class||''}">${tds}</tr>`;
            }).join('\n');

            return `<div class="table-wrap"><table class="grid">${thead}<tbody>${tbody}</tbody></table></div>`;
          }

          (async () => {
            if (!(await exists(inPath))) { core.setFailed(`IN path not found: ${inPath}`); return; }

            const files = [];
            if (await isDir(inPath)) for await (const f of walk(inPath)) files.push(f);
            else files.push(inPath);

            let overallErr=0, overallWarn=0, overallInfo=0;
            const sections=[];

            for (const file of files) {
              let json;
              try { json = JSON.parse(await fs.readFile(file,'utf8')); }
              catch (e){ core.warning(`Skipping ${file}: ${e.message}`); continue; }

              const rows = toResultsArray(json).map(x=>({
                ErrorSeverity: Number(x.ErrorSeverity ?? 0),
                ErrorCode: String(x.ErrorCode ?? ''),
                DocumentationLink: String(x.DocumentationLink ?? ''),
                RuleName: String(x.RuleName ?? ''),
                Description: x.Description ?? '',
                Recommendation: x.Recommendation ?? '',
                FilePath: String(x.FilePath ?? '')
              }));

              // sort: Error -> Warning -> Info, then by Rule, then File
              rows.sort((a,b)=>
                (a.ErrorSeverity - b.ErrorSeverity) ||
                String(a.RuleName).localeCompare(String(b.RuleName)) ||
                String(a.FilePath).localeCompare(String(b.FilePath))
              );

              const counts = {
                err: rows.filter(r=>r.ErrorSeverity===1).length,
                warn:rows.filter(r=>r.ErrorSeverity===2).length,
                info:rows.filter(r=>r.ErrorSeverity===3).length,
              };
              overallErr+=counts.err; overallWarn+=counts.warn; overallInfo+=counts.info;

              sections.push(`
                <details open>
                  <summary><span class="file">${escapeHtml(path.basename(file))}</span>
                    <span class="chips">
                      <span class="chip error">❌ ${counts.err}</span>
                      <span class="chip warn">⚠️ ${counts.warn}</span>
                      <span class="chip info">ℹ️ ${counts.info}</span>
                    </span>
                  </summary>
                  ${renderTable(rows)}
                </details>`);
                        }

            const css = `
              :root { --fg:#0f172a; --muted:#475569; --bg:#ffffff; --bd:#e5e7eb;
                      --err:#fee2e2; --warn:#fff7ed; --info:#eff6ff; --chip:#e2e8f0; }
              * { box-sizing: border-box; }
              body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
                    margin:24px; color:var(--fg); background:var(--bg); }
              h1 { margin:0 0 4px; }
              .sub { color:var(--muted); margin:0 0 16px; }
              details { border:1px solid var(--bd); border-radius:10px; margin:12px 0; background:#fff; overflow:hidden; }
              summary { cursor:pointer; padding:12px 16px; font-weight:600; display:flex; align-items:center; gap:12px; }
              .file { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
              .chips { margin-left:auto; display:flex; gap:8px; }
              .chip { background:var(--chip); border-radius:999px; padding:2px 10px; font-size:12px; }
              .chip.error { background:#fecaca; } .chip.warn { background:#fed7aa; } .chip.info { background:#bfdbfe; }
              .table-wrap { overflow:auto; max-width:100%; }
              .grid { width:100%; border-collapse:separate; border-spacing:0; table-layout:fixed; border:1px solid var(--bd); }
              .grid th, .grid td { border:1px solid var(--bd); padding:8px 10px; vertical-align:top; }
              .grid th { background:#f8fafc; position:sticky; top:0; z-index:1; }
              .grid td, .grid th { overflow-wrap:anywhere; word-break:break-word; }
              td.sev { white-space:nowrap; width:120px; }
              td.path { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
              tr.sev-error   { background: var(--err); }
              tr.sev-warning { background: var(--warn); }
              tr.sev-info    { background: var(--info); }
              .list { margin:0; padding-left:18px; }
            `;

            const when = new Date().toISOString();
            const html = `<!doctype html>
            <html><head><meta charset="utf-8" />
            <title>UiPath Analyzer Report</title>
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <style>${css}</style></head>
            <body>
              <h1>UiPath Analyzer Report</h1>
              <p class="sub">Generated: ${escapeHtml(when)}</p>
              <div class="chips">
                <span class="chip error">❌ Errors: ${overallErr}</span>
                <span class="chip warn">⚠️ Warnings: ${overallWarn}</span>
                <span class="chip info">ℹ️ Info: ${overallInfo}</span>
              </div>
              ${sections.join('\n')}
            </body></html>`;

            await fs.mkdir(path.dirname(outPath), { recursive:true });
            await fs.writeFile(outPath, html, 'utf8');
            core.setOutput('html_path', outPath);
            core.info(`HTML report written to ${outPath}`);
          })();
