name: Decide target env
description: Compute target_env/skip/source_ref for Pipeline Caller
author: you
inputs:
  token:
    description: GitHub token with repo read permissions
    required: false
    default: ${{ github.token }}
outputs:
  target_env:
    description: dev | test | prod | hotfix
    value: ${{ steps.decider.outputs.target_env }}
  skip:
    description: if the caller should skip running the pipeline
    value: ${{ steps.decider.outputs.skip }}
  source_ref:
    description: SHA to pass to downstream pipeline
    value: ${{ steps.decider.outputs.source_ref }}

runs:
  using: composite
  steps:
    - name: Compute env/skip via GitHub API
      id: decider
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const eventName = context.eventName;
          const defaultBranch = context.payload.repository?.default_branch;
          const owner = context.repo.owner;
          const repo  = context.repo.repo;

          const ref = context.ref || ''; // refs/heads/<branch>
          const refName = ref.startsWith('refs/heads/') ? ref.slice('refs/heads/'.length) : ref;

          let targetEnv = '';
          let skip = false;

          if (eventName === 'pull_request') {
            const action = context.payload.action;
            const pr = context.payload.pull_request;
            const isDraft = !!pr?.draft;

            if (action === 'ready_for_review') {
              // Transition to test when draft → RfR
              targetEnv = 'test';
            } else if (action === 'opened' || action === 'reopened' || action === 'synchronize') {
              if (isDraft) {
                // Keep drafts in dev, but SKIP PR-triggered runs while draft
                // (push runs will still fire and set dev below)
                targetEnv = 'dev';
                skip = true;
              } else {
                // Non-draft PR events use test (includes synchronize after RfR)
                targetEnv = 'test';
              }
            } else {
              // Any other PR action not relevant
              skip = true;
            }
          } else if (eventName === 'push') {
            if (refName.startsWith('feature/') || refName.startsWith('hotfix/')) {
              // Check for an open PR on this branch
              const prs = await github.rest.pulls.list({
                owner, repo, head: `${owner}:${refName}`, state: 'open'
              });
              const pr = prs.data[0];

              if (pr) {
                if (pr.draft) {
                  // Draft PR exists → still run push as dev
                  targetEnv = 'dev';
                  skip = false;
                } else {
                  // Non-draft PR exists → skip push (PR 'synchronize' will run as test)
                  targetEnv = 'test'; // informational
                  skip = true;
                }
              } else {
                // No PR → dev on push
                targetEnv = 'dev';
              }
            } else if (refName === defaultBranch) {
              // Merge to default → prod unless merged PR was from hotfix/*
              const afterSha = context.payload.after || context.sha;
              let isHotfix = false;
              try {
                const assoc = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner, repo, commit_sha: afterSha
                });
                const pr = assoc.data.find(p => p.merged_at) || assoc.data[0];
                if (pr?.head?.ref?.startsWith('hotfix/')) {
                  isHotfix = true;
                }
              } catch (e) {
                core.info(`Could not inspect associated PRs: ${e.message}`);
              }
              targetEnv = isHotfix ? 'hotfix' : 'prod';
            } else {
              // Any other branch → do nothing
              skip = true;
            }
          } else {
            // Any other event → do nothing
            skip = true;
          }

          const sourceRef = (eventName === 'pull_request')
            ? context.payload.pull_request.head.sha
            : context.sha;

          core.setOutput('target_env', targetEnv);
          core.setOutput('skip', skip ? 'true' : 'false');
          core.setOutput('source_ref', sourceRef);
