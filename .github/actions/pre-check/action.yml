name: Decide target env
description: Compute target_env/skip/source_ref for Pipeline Caller
inputs:
  token:
    description: GitHub token with repo read permissions
    required: false
    default: ${{ github.token }}
outputs:
  target_env:
    description: dev | test | prod | hotfix
    value: ${{ steps.decider.outputs.target_env }}
  skip:
    description: if the caller should skip running the pipeline
    value: ${{ steps.decider.outputs.skip }}
  source_ref:
    description: SHA to pass to downstream pipeline
    value: ${{ steps.decider.outputs.source_ref }}

runs:
  using: composite
  steps:
    - name: Compute env/skip via GitHub API
      id: decider
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const event = context.eventName;
          const defaultBranch = context.payload.repository?.default_branch;
          const { owner, repo } = context.repo;

          const refName = (context.ref || '').replace(/^refs\/heads\//, '');
          let targetEnv = '';
          let skip = false;

          if (event === 'pull_request') {
            const pr = context.payload.pull_request;
            const baseRef = pr?.base?.ref;
            const action = context.payload.action;
            const isDraft = !!pr?.draft;

            // Only PRs into default branch are relevant
            if (baseRef !== defaultBranch) {
              skip = true;
            } else if (isDraft) {
              // Draft PR runs as dev
              targetEnv = 'dev';
            } else if (['opened', 'reopened', 'ready_for_review', 'synchronize'].includes(action)) {
              targetEnv = 'test';
            } else {
              skip = true;
            }
          } else if (event === 'push') {
            if (refName === defaultBranch) {
              // Merge to default â†’ prod unless merged PR head was hotfix/*
              const afterSha = context.payload.after || context.sha;
              let isHotfix = false;
              try {
                const assoc = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: afterSha });
                const pr = assoc.data.find(p => p.merged_at) || assoc.data[0];
                if (pr?.head?.ref?.startsWith('hotfix/')) isHotfix = true;
              } catch {}
              targetEnv = isHotfix ? 'hotfix' : 'prod';
            } else if (refName.startsWith('feature/') || refName.startsWith('hotfix/')) {
              // Skip push if any PR is open for this branch (draft or not)
              const prs = await github.rest.pulls.list({ owner, repo, head: `${owner}:${refName}`, state: 'open' });
              if (prs.data.length > 0) {
                skip = true;
              } else {
                targetEnv = 'dev';
              }
            } else {
              // Ignore other branches
              skip = true;
            }
          } else {
            skip = true;
          }

          const sourceRef = event === 'pull_request'
            ? context.payload.pull_request.head.sha
            : context.sha;

          core.setOutput('target_env', targetEnv);
          core.setOutput('skip', skip ? 'true' : 'false');
          core.setOutput('source_ref', sourceRef);
